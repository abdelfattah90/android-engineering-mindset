<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <title>Memory Management - ÙƒÙŠÙ ÙŠØ¯ÙŠØ± Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø°Ø§ÙƒØ±Ø©ØŸ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f7f8fa;
      --card: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --border: #e5e7eb;
      --accent: #2563eb;
      --code-bg: #666666;
      --code-text: #ffffff;
    }

    * {
      box-sizing: border-box;
      font-family: 'Nunito', 'Segoe UI', Tahoma, Arial, sans-serif;
    }

    body {
      margin: 0;
      font-family: 'Nunito', 'Segoe UI', Tahoma, Arial, sans-serif; 
      background: var(--bg);
      color: var(--text);
      line-height: 1.8;
    }

    .page {
      max-width: 980px;
      margin: auto;
      padding: 32px 16px;
    }

    .content {
      background: var(--card);
      border-radius: 12px;
      padding: 32px;
      border: 1px solid var(--border);
    }

    h1, h2, h3, h4 {
      color: #111827;
      margin-top: 32px;
    }

    h1 {
      font-size: 2.1rem;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 8px;
    }

    h2 {
      font-size: 1.6rem;
      border-right: 4px solid var(--accent);
      padding-right: 12px;
    }

    h3 {
      font-size: 1.3rem;
    }

    h4 {
      font-size: 1.1rem;
      color: #374151;
    }

    p {
      margin: 12px 0;
    }

    hr {
      margin: 40px 0;
      border: none;
      height: 1px;
      background: var(--border);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0;
      font-size: 0.95rem;
    }

    table th,
    table td {
      border: 1px solid var(--border);
      padding: 10px;
      text-align: right;
    }

    table th {
      background: #f1f5f9;
      font-weight: 600;
    }

    ul, ol {
      padding-right: 20px;
    }

    blockquote {
      background: #f1f5f9;
      border-right: 4px solid var(--accent);
      padding: 12px 16px;
      margin: 16px 0;
      color: #374151;
    }

    pre {
      background: var(--code-bg);
      color: var(--code-text);
      padding: 16px;
      border-radius: 10px;
      overflow-x: auto;
      margin: 16px 0;
      font-size: 0.9rem;
      direction: ltr;
      text-align: left;
    }

    code {
      font-family: 'Roboto Mono', 'Courier New', monospace;
    }

    p code {
      background: #eef2ff;
      color: #1e40af;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 0.85em;
    }

    section {
      margin-bottom: 32px;
    }

    .warning {
      background: #fef2f2;
      border-right: 4px solid #dc2626;
      padding: 12px 16px;
      margin: 16px 0;
      color: #991b1b;
    }

    .success {
      background: #f0fdf4;
      border-right: 4px solid #16a34a;
      padding: 12px 16px;
      margin: 16px 0;
      color: #166534;
    }

    .info {
      background: #eff6ff;
      border-right: 4px solid #2563eb;
      padding: 12px 16px;
      margin: 16px 0;
      color: #1e40af;
    }

    @media (max-width: 600px) {
      .content {
        padding: 20px;
      }

      h1 {
        font-size: 1.7rem;
      }

      h2 {
        font-size: 1.4rem;
      }
    }
  </style>
</head>

<body>
  <div class="page">
    <div class="content">
      <div class="crossnote markdown-preview">
        <div dir="rtl">
          <h1>ÙƒÙŠÙ ÙŠØ¯ÙŠØ± Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© MemoryØŸ ğŸ§ </h1>

          <h2>Ø§Ù„Ù…Ø­ØªÙˆÙŠØ§Øª</h2>
          <p>
            1 - Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©: Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯Ø©<br />
            2 - Ø§Ù„ØªØ´Ø¨ÙŠÙ‡ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ: Ø§Ù„Ù…ÙƒØªØ¨Ø© ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØªØ¨<br />
            3 - Virtual Memory: Ø§Ù„ÙˆÙ‡Ù… Ø§Ù„Ø¹Ø¨Ù‚Ø±ÙŠ<br />
            4 - Physical vs Virtual Memory<br />
            5 - Paging: ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù„ØµÙØ­Ø§Øª<br />
            6 - Page Tables: Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø³Ø­Ø±ÙŠØ©<br />
            7 - TLB: Cache Ù„Ù„ØªØ±Ø¬Ù…Ø©<br />
            8 - Page Faults: Ø¹Ù†Ø¯Ù…Ø§ Ù„Ø§ Ù†Ø¬Ø¯ Ø§Ù„ØµÙØ­Ø©<br />
            9 - Memory Allocation Strategies<br />
            10 - Memory ÙÙŠ Android ØªØ­Ø¯ÙŠØ¯Ù‹Ø§<br />
            11 - Garbage Collection<br />
            12 - Memory Leaks ÙˆÙƒÙŠÙÙŠØ© ØªØ¬Ù†Ø¨Ù‡Ø§<br />
            13 - Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ© Ù…Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹<br />
            14 - Ø§Ù„Ø®Ù„Ø§ØµØ© ÙˆØ§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
          </p>

          <hr />

          <h2>Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©: Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯Ø© ğŸ¯</h2>

          <h3>Ø§Ù„Ù…Ø¹Ø¶Ù„Ø© Ø§Ù„Ø£Ø²Ù„ÙŠØ©:</h3>

          <blockquote>
            <strong>Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:</strong><br />
            Ù„Ø¯ÙŠÙƒ <strong>8 GB RAM</strong> (Ù…Ø§Ø¯ÙŠØ© Ù…Ø­Ø¯ÙˆØ¯Ø©)<br />
            Ù„Ø¯ÙŠÙƒ <strong>100 ØªØ·Ø¨ÙŠÙ‚</strong> ÙŠØ±ÙŠØ¯ÙˆÙ† Ø§Ù„Ø°Ø§ÙƒØ±Ø©<br />
            ÙƒÙ„ ØªØ·Ø¨ÙŠÙ‚ ÙŠØ¹ØªÙ‚Ø¯ Ø£Ù† Ù„Ø¯ÙŠÙ‡ <strong>Ø°Ø§ÙƒØ±Ø© Ù„Ø§ Ù…Ø­Ø¯ÙˆØ¯Ø©</strong>!<br />
            <br />
            <strong>Ø§Ù„Ø³Ø¤Ø§Ù„:</strong><br />
            ÙƒÙŠÙ Ù†Ø¹Ø·ÙŠ ÙƒÙ„ Process "ÙˆÙ‡Ù…" Ø£Ù† Ù„Ù‡ Ø°Ø§ÙƒØ±Ø© Ø®Ø§ØµØ© ÙˆÙƒØ¨ÙŠØ±Ø©ØŒ<br />
            Ø¨ÙŠÙ†Ù…Ø§ ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ Ù„Ø¯ÙŠÙ†Ø§ 8 GB ÙÙ‚Ø· Ù†ØªØ´Ø§Ø±ÙƒÙ‡Ø§ Ø¬Ù…ÙŠØ¹Ø§Ù‹ØŸ<br />
            <br />
            <strong>â†’ Ù‡Ø°Ø§ Ù‡Ùˆ Memory Management!</strong>
          </blockquote>

          <h3>Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ù…ØªØ¶Ø§Ø±Ø¨Ø©:</h3>

          <div class="info">
            <strong>ğŸ¯ Ø£Ù‡Ø¯Ø§Ù Memory Manager:</strong><br />
            <br />
            <strong>1. Isolation (Ø§Ù„Ø¹Ø²Ù„):</strong><br />
            â€¢ ÙƒÙ„ Process Ù„Ù‡ Ù…Ø³Ø§Ø­Ø© Ù…Ø¹Ø²ÙˆÙ„Ø©<br />
            â€¢ Process A Ù„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ Ù‚Ø±Ø§Ø¡Ø©/ØªØ¹Ø¯ÙŠÙ„ Ø°Ø§ÙƒØ±Ø© Process B<br />
            â€¢ Ø§Ù„Ø£Ù…Ø§Ù† ÙˆØ§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±<br />
            <br />
            <strong>2. Transparency (Ø§Ù„Ø´ÙØ§ÙÙŠØ©):</strong><br />
            â€¢ Process ÙŠØ¹ØªÙ‚Ø¯ Ø£Ù† Ù„Ù‡ Ø°Ø§ÙƒØ±Ø© ÙƒØ¨ÙŠØ±Ø© ÙˆÙ…Ø³ØªÙ…Ø±Ø©<br />
            â€¢ Ù„Ø§ ÙŠØ¹Ø±Ù Ø¹Ù† Processes Ø§Ù„Ø£Ø®Ø±Ù‰<br />
            â€¢ ÙŠØ³ØªØ®Ø¯Ù… Addresses Ø³Ù‡Ù„Ø© (0x0000 - 0xFFFF...)<br />
            <br />
            <strong>3. Efficiency (Ø§Ù„ÙƒÙØ§Ø¡Ø©):</strong><br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ø§Ù… RAM Ø¨Ø£Ù‚ØµÙ‰ ÙƒÙØ§Ø¡Ø©<br />
            â€¢ Ù„Ø§ Ù‡Ø¯Ø±ØŒ Ù„Ø§ Fragmentation<br />
            â€¢ Access Ø³Ø±ÙŠØ¹ (Cache-friendly)<br />
            <br />
            <strong>4. Sharing (Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©):</strong><br />
            â€¢ Processes ØªØ´Ø§Ø±Ùƒ Code segments (Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª)<br />
            â€¢ ØªÙ‚Ù„ÙŠÙ„ Memory footprint<br />
            â€¢ Ù…Ø«Ø§Ù„: 100 app ÙŠØ³ØªØ®Ø¯Ù…ÙˆÙ† Android Framework â†’ Ù†Ø³Ø®Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙŠ RAM!<br />
            <br />
            <strong>â†’ Ø§Ù„ØªÙˆØ§Ø²Ù† Ø¨ÙŠÙ† Ù‡Ø°Ù‡ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù = ÙÙ† Memory Management!</strong>
          </div>

          <h3>Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:</h3>

          <div dir="ltr">
            <pre>Memory Management Problem:

Given:
â€¢ Limited Physical RAM (e.g., 8 GB)
â€¢ Many Processes (100+) wanting memory
â€¢ Each Process wants "unlimited" memory
â€¢ Need for isolation (security)
â€¢ Need for performance (speed)

Provide:
â€¢ Illusion of large, private address space per Process
â€¢ Protection between Processes
â€¢ Efficient use of Physical RAM
â€¢ Fast memory access

Solution:
â†’ Virtual Memory + Paging + Page Tables + TLB + Smart Allocation</pre>
          </div>

          <hr />

          <h2>Ø§Ù„ØªØ´Ø¨ÙŠÙ‡ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ: Ø§Ù„Ù…ÙƒØªØ¨Ø© ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØªØ¨ ğŸ“š</h2>

          <h3>ØªØ®ÙŠÙ„ Ù…ÙƒØªØ¨Ø© Ø¶Ø®Ù…Ø©:</h3>

          <div dir="ltr">
            <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   University Library                 â”‚
â”‚                (Operating System)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Reading Desks (Physical RAM):                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Desk 1 â”‚ â”‚ Desk 2 â”‚ â”‚ Desk 3 â”‚ â”‚ Desk 4 â”‚      â”‚
â”‚  â”‚ 2 GB   â”‚ â”‚ 2 GB   â”‚ â”‚ 2 GB   â”‚ â”‚ 2 GB   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚  Total: 8 GB (Ù…Ø­Ø¯ÙˆØ¯Ø©!)                              â”‚
â”‚                                                      â”‚
â”‚  Storage Warehouse (Disk/SSD):                      â”‚
â”‚  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]                     â”‚
â”‚  500 GB (ÙƒØ¨ÙŠØ±Ø© Ù„ÙƒÙ† Ø¨Ø·ÙŠØ¦Ø©!)                          â”‚
â”‚                                                      â”‚
â”‚  Students (Processes):                              â”‚
â”‚  ğŸ‘¨â€ğŸ“ ğŸ‘©â€ğŸ“ ğŸ‘¨â€ğŸ“ ğŸ‘©â€ğŸ“ ğŸ‘¨â€ğŸ“ (100 students)                      â”‚
â”‚  Each wants books (memory)                          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

How Library Works (Memory Manager):

1. Student ÙŠØ·Ù„Ø¨ ÙƒØªØ§Ø¨:
   "Ø£Ø±ÙŠØ¯ ÙƒØªØ§Ø¨ Ø±Ù‚Ù… 12345" (Virtual Address)

2. Librarian (MMU) ÙŠØªØ±Ø¬Ù…:
   "ÙƒØªØ§Ø¨ 12345 Ù…ÙˆØ¬ÙˆØ¯ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù 42" (Physical Address)

3. If book Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù (ÙÙŠ RAM):
   â””â”€â†’ ÙŠØ¹Ø·ÙŠÙ‡ Ù„Ù„Ø·Ø§Ù„Ø¨ ÙÙˆØ±Ø§Ù‹ âœ“ (Fast!)

4. If book ÙÙŠ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ (Ø¹Ù„Ù‰ Disk):
   â””â”€â†’ ÙŠØ°Ù‡Ø¨ Ù„Ø¥Ø­Ø¶Ø§Ø±Ù‡ (Page Fault)
       â””â”€â†’ Ø¥Ø°Ø§ Ø§Ù„Ø±ÙÙˆÙ Ù…Ù…ØªÙ„Ø¦Ø©ØŒ ÙŠØ±Ø¬Ø¹ ÙƒØªØ§Ø¨ Ù‚Ø¯ÙŠÙ… Ù„Ù„Ù…Ø³ØªÙˆØ¯Ø¹ (Swap)
           â””â”€â†’ ÙŠØ¶Ø¹ Ø§Ù„ÙƒØªØ§Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù
               â””â”€â†’ ÙŠØ¹Ø·ÙŠÙ‡ Ù„Ù„Ø·Ø§Ù„Ø¨ (Slow!)

5. Catalog System (Page Tables):
   â€¢ ÙƒÙ„ Ø·Ø§Ù„Ø¨ Ù„Ù‡ Catalog Ø®Ø§Øµ
   â€¢ ÙŠØ¹ØªÙ‚Ø¯ Ø£Ù† ÙƒÙ„ Ø§Ù„ÙƒØªØ¨ Ù…ØªØ§Ø­Ø© Ù„Ù‡
   â€¢ Ù„Ø§ ÙŠØ¹Ø±Ù Ø¹Ù† Ø·Ù„Ø§Ø¨ Ø¢Ø®Ø±ÙŠÙ†
   â€¢ Librarian ÙŠØ¯ÙŠØ± Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø®Ù„Ù Ø§Ù„ÙƒÙˆØ§Ù„ÙŠØ³</pre>
          </div>

          <blockquote>
            <strong>ğŸ¯ Ø§Ù„Ø¯Ø±ÙˆØ³:</strong><br />
            1. <strong>Virtual Address:</strong> Ø±Ù‚Ù… Ø§Ù„ÙƒØªØ§Ø¨ Ø§Ù„Ø°ÙŠ ÙŠØ¹Ø±ÙÙ‡ Ø§Ù„Ø·Ø§Ù„Ø¨<br />
            2. <strong>Physical Address:</strong> Ø§Ù„Ù…ÙƒØ§Ù† Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù<br />
            3. <strong>Page Table:</strong> Catalog Ø§Ù„Ø°ÙŠ ÙŠØªØ±Ø¬Ù… Ø¨ÙŠÙ† Ø§Ù„Ø§Ø«Ù†ÙŠÙ†<br />
            4. <strong>Page Fault:</strong> Ø§Ù„ÙƒØªØ§Ø¨ Ù„ÙŠØ³ Ø¹Ù„Ù‰ Ø§Ù„Ø±ÙØŒ ÙŠØ­ØªØ§Ø¬ Ø¥Ø­Ø¶Ø§Ø±<br />
            5. <strong>Swapping:</strong> Ø¥Ø±Ø¬Ø§Ø¹ ÙƒØªØ§Ø¨ Ù‚Ø¯ÙŠÙ… Ù„Ø¥Ø­Ø¶Ø§Ø± Ø¬Ø¯ÙŠØ¯<br />
            6. <strong>Isolation:</strong> ÙƒÙ„ Ø·Ø§Ù„Ø¨ Ù„Ù‡ Catalog Ø®Ø§ØµØŒ Ù„Ø§ ÙŠØ±Ù‰ ÙƒØªØ¨ Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
          </blockquote>

          <hr />

          <h2>Virtual Memory: Ø§Ù„ÙˆÙ‡Ù… Ø§Ù„Ø¹Ø¨Ù‚Ø±ÙŠ ğŸ­</h2>

          <h3>Ù…Ø§ Ù‡Ùˆ Virtual MemoryØŸ</h3>

          <blockquote>
            <strong>Virtual Memory:</strong><br />
            ÙƒÙ„ Process ÙŠØ±Ù‰ <strong>Ù…Ø³Ø§Ø­Ø© Ø¹Ù†ÙˆÙ†Ø© ÙˆÙ‡Ù…ÙŠØ© Ø¶Ø®Ù…Ø©</strong> (Ù…Ø«Ù„Ø§Ù‹ 4 GB Ø¹Ù„Ù‰ 32-bitØŒ Ø£Ùˆ 256 TB Ø¹Ù„Ù‰ 64-bit!)<br />
            <br />
            Process ÙŠØ¹ØªÙ‚Ø¯:<br />
            â€¢ "Ù„Ø¯ÙŠ Ø°Ø§ÙƒØ±Ø© Ù…Ù† 0x00000000 Ø¥Ù„Ù‰ 0xFFFFFFFF"<br />
            â€¢ "ÙƒÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ù„ÙŠ ÙˆØ­Ø¯ÙŠ"<br />
            â€¢ "Ù„Ø§ Ø£Ø­Ø¯ ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ø°Ø§ÙƒØ±ØªÙŠ"<br />
            <br />
            <strong>Ø§Ù„ÙˆØ§Ù‚Ø¹:</strong><br />
            â€¢ Physical RAM Ù…Ø­Ø¯ÙˆØ¯Ø© (8 GB Ù…Ø«Ù„Ø§Ù‹)<br />
            â€¢ ØªÙØ´Ø§Ø±Ùƒ Ø¨ÙŠÙ† 100+ Processes<br />
            â€¢ OS ÙŠØªØ±Ø¬Ù… Virtual Addresses Ø¥Ù„Ù‰ Physical Addresses Ø®Ù„Ù Ø§Ù„ÙƒÙˆØ§Ù„ÙŠØ³<br />
            <br />
            <strong>â†’ Virtual Memory = Ø§Ù„ÙˆÙ‡Ù… Ø§Ù„Ø°ÙŠ ÙŠØ¨Ø³Ù‘Ø· Ø§Ù„Ø¨Ø±Ù…Ø¬Ø© ÙˆÙŠØ­Ù…ÙŠ Ø§Ù„Ø£Ù…Ø§Ù†!</strong>
          </blockquote>

          <h3>Ø§Ù„ÙÙˆØ§Ø¦Ø¯ Ø§Ù„Ø¹Ø¨Ù‚Ø±ÙŠØ©:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„ÙØ§Ø¦Ø¯Ø©</th>
                <th>Ø§Ù„Ø´Ø±Ø­</th>
                <th>Ø§Ù„Ù…Ø«Ø§Ù„</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Isolation</strong></td>
                <td>ÙƒÙ„ Process Ù…Ø¹Ø²ÙˆÙ„ ØªÙ…Ø§Ù…Ø§Ù‹</td>
                <td>Malware Ù„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ Ù‚Ø±Ø§Ø¡Ø© Ø¨ÙŠØ§Ù†Ø§Øª Banking app</td>
              </tr>
              <tr>
                <td><strong>Simplicity</strong></td>
                <td>Addresses Ø¨Ø³ÙŠØ·Ø© Ù„Ù„Ù…Ø¨Ø±Ù…Ø¬</td>
                <td>ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… 0x0000 ÙÙŠ ÙƒÙ„ Process</td>
              </tr>
              <tr>
                <td><strong>Over-commitment</strong></td>
                <td>Ø¥Ø¹Ø·Ø§Ø¡ Ø£ÙƒØ«Ø± Ù…Ù† RAM Ø§Ù„ÙØ¹Ù„ÙŠØ©</td>
                <td>100 app ÙƒÙ„ ÙˆØ§Ø­Ø¯ ÙŠØ¹ØªÙ‚Ø¯ Ù„Ù‡ 1 GB â†’ 100 GB ÙˆÙ‡Ù…ÙŠØ©!</td>
              </tr>
              <tr>
                <td><strong>Sharing</strong></td>
                <td>Ù…Ø´Ø§Ø±ÙƒØ© Code Ø¨ÙŠÙ† Processes</td>
                <td>Android Framework Ù…Ø´ØªØ±Ùƒ Ø¨ÙŠÙ† ÙƒÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª</td>
              </tr>
              <tr>
                <td><strong>Relocation</strong></td>
                <td>Process Ù„Ø§ ÙŠÙ‡ØªÙ… Ø¨Ù…ÙƒØ§Ù†Ù‡ Ø§Ù„ÙØ¹Ù„ÙŠ</td>
                <td>ÙŠÙ…ÙƒÙ† Ù†Ù‚Ù„Ù‡ ÙÙŠ RAM Ø¨Ø¯ÙˆÙ† ØªØ£Ø«ÙŠØ±</td>
              </tr>
            </tbody>
          </table>

          <hr />

          <h2>Physical vs Virtual Memory ğŸ”„</h2>

          <h3>Ø§Ù„ÙØ±Ù‚ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ:</h3>

          <div dir="ltr">
            <pre>Virtual Memory (Ù…Ø§ ÙŠØ±Ø§Ù‡ Process):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Process A's View:                       â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 0x00000000: Code Segment            â”‚ â”‚
â”‚ â”‚ 0x00400000: Data Segment            â”‚ â”‚
â”‚ â”‚ 0x00600000: Heap (grows up â†‘)       â”‚ â”‚
â”‚ â”‚     ...                             â”‚ â”‚
â”‚ â”‚ 0x7FFFFFFF: Stack (grows down â†“)    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ Size: 2 GB (thinks it has this much!)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Physical Memory (Ø§Ù„ÙˆØ§Ù‚Ø¹ ÙÙŠ RAM):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Physical RAM (8 GB total):              â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 0x00000000: [Kernel Code]           â”‚ â”‚
â”‚ â”‚ 0x10000000: [Process C - Code]      â”‚ â”‚
â”‚ â”‚ 0x20000000: [Process A - Stack]     â”‚ â”‚ â† A's stack
â”‚ â”‚ 0x30000000: [Process B - Heap]      â”‚ â”‚
â”‚ â”‚ 0x40000000: [Process A - Code]      â”‚ â”‚ â† A's code
â”‚ â”‚ 0x50000000: [Free]                  â”‚ â”‚
â”‚ â”‚ 0x60000000: [Process B - Stack]     â”‚ â”‚
â”‚ â”‚     ...                             â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ Fragmented, shared, managed by OS      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Translation (MMU's Job):
Process A: "Ø£Ø±ÙŠØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† 0x00401234" (Virtual)
           â†“ MMU translates
RAM:       "Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ 0x40001234" (Physical)

Process B: "Ø£Ø±ÙŠØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† 0x00401234" (Virtual - Ù†ÙØ³ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†!)
           â†“ MMU translates (Ù„ÙƒÙ† Ù„Ù€ Ù…ÙƒØ§Ù† Ù…Ø®ØªÙ„Ù!)
RAM:       "Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ 0x30005678" (Physical - Ù…Ø®ØªÙ„Ù ØªÙ…Ø§Ù…Ø§Ù‹!)

Result: ÙƒÙ„ Process ÙŠØ³ØªØ®Ø¯Ù… Ù†ÙØ³ Virtual AddressesØŒ Ù„ÙƒÙ† ØªÙØªØ±Ø¬Ù… Ù„Ø£Ù…Ø§ÙƒÙ† Ù…Ø®ØªÙ„ÙØ©! âœ“</pre>
          </div>

          <h3>MMU (Memory Management Unit):</h3>

          <div dir="ltr">
            <pre>MMU: Hardware ÙŠØªØ±Ø¬Ù… Addresses ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹

Every Memory Access:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CPU: "Load from address 0x00401234"      â”‚
â”‚      (Virtual Address)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MMU: Automatic Translation               â”‚
â”‚ 1. Check Page Tables                     â”‚
â”‚ 2. Find Physical Address                 â”‚
â”‚ 3. Check Permissions (Read/Write/Execute)â”‚
â”‚ 4. Translate: 0x00401234 â†’ 0x40001234   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RAM: Return data from 0x40001234         â”‚
â”‚      (Physical Address)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Cost: ~1-2 CPU cycles (with TLB cache)
Without MMU: Process ÙŠÙ…ÙƒÙ†Ù‡ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ø£ÙŠ Ù…ÙƒØ§Ù† (Ø®Ø·Ø±!)
With MMU: Process Ù…Ø­Ø¨ÙˆØ³ ÙÙŠ Virtual space (Ø¢Ù…Ù†!) âœ“</pre>
          </div>

          <hr />

          <h2>Paging: ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù„ØµÙØ­Ø§Øª ğŸ“„</h2>

          <h3>Ù„Ù…Ø§Ø°Ø§ PagingØŸ</h3>

          <blockquote>
            <strong>Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:</strong> Ø¥Ø°Ø§ Ø£Ø¹Ø·ÙŠÙ†Ø§ ÙƒÙ„ Process Ù…Ø³Ø§Ø­Ø© Ù…Ø³ØªÙ…Ø±Ø© ÙƒØ¨ÙŠØ±Ø© â†’ Fragmentation!<br />
            <br />
            <strong>Ø§Ù„Ø­Ù„:</strong> Ù†Ù‚Ø³Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø¥Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª ØµØºÙŠØ±Ø© Ù…ØªØ³Ø§ÙˆÙŠØ© (Pages)<br />
            â€¢ Page size Ù†Ù…ÙˆØ°Ø¬ÙŠ: 4 KB<br />
            â€¢ Virtual Memory = Pages Ù…ØªØªØ§Ù„ÙŠØ© (ÙÙŠ Ù†Ø¸Ø± Process)<br />
            â€¢ Physical Memory = Pages Ù…ØªÙØ±Ù‚Ø© (ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹)<br />
            â€¢ MMU ÙŠØªØ±Ø¬Ù… Page by Page
          </blockquote>

          <h3>ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ PagingØŸ</h3>

          <div dir="ltr">
            <pre>Page Size = 4 KB (4096 bytes)

Virtual Address (32-bit): 0x00401234
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Page Number â”‚  Page Offset   â”‚
â”‚   20 bits    â”‚    12 bits     â”‚
â”‚   0x00401    â”‚     0x234      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“                â†“
     â”‚                â”‚
     â”‚                â””â”€â†’ Offset Ø¯Ø§Ø®Ù„ Page (0-4095)
     â”‚
     â””â”€â†’ Ø£ÙŠ PageØŸ (ÙŠÙØªØ±Ø¬Ù… Ø¹Ø¨Ø± Page Table)

Translation:
Page Number: 0x00401 (Virtual Page Number - VPN)
     â†“ Lookup in Page Table
Physical Frame Number: 0x08042 (PFN)

Physical Address:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Frame Numberâ”‚  Page Offset   â”‚
â”‚   0x08042    â”‚     0x234      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
= 0x08042234 (Physical Address)

Process ÙŠØ³ØªØ®Ø¯Ù…: 0x00401234 (Virtual)
RAM ÙŠØ­ØªÙˆÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ: 0x08042234 (Physical)

Key Point: Offset Ù„Ø§ ÙŠØªØºÙŠØ±ØŒ ÙÙ‚Ø· Page/Frame Number ÙŠÙØªØ±Ø¬Ù…!</pre>
          </div>

          <h3>Virtual Pages vs Physical Frames:</h3>

          <div dir="ltr">
            <pre>Virtual Memory (Process View):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Virtual Pages (Ù…ØªØªØ§Ù„ÙŠØ©):        â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚ â”‚ VPN 0â”‚ â†’ Code                 â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”¤                        â”‚
â”‚ â”‚ VPN 1â”‚ â†’ Code                 â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”¤                        â”‚
â”‚ â”‚ VPN 2â”‚ â†’ Data                 â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”¤                        â”‚
â”‚ â”‚ VPN 3â”‚ â†’ Heap                 â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”¤                        â”‚
â”‚ â”‚  ... â”‚                        â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚ Contiguous (Ù…ØªØªØ§Ù„ÙŠØ©)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Physical Memory (Reality):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Physical Frames (Ù…ØªÙØ±Ù‚Ø©):       â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚ â”‚PFN 5 â”‚ â† VPN 0 mapped here    â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”¤                        â”‚
â”‚ â”‚PFN 12â”‚ â† VPN 2 mapped here    â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”¤                        â”‚
â”‚ â”‚PFN 3 â”‚ â† VPN 1 mapped here    â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”¤                        â”‚
â”‚ â”‚PFN 20â”‚ â† VPN 3 mapped here    â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”¤                        â”‚
â”‚ â”‚  ... â”‚                        â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚ Scattered (Ù…ØªÙØ±Ù‚Ø©)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Advantage:
â€¢ No External Fragmentation! âœ“
â€¢ Virtual pages Ù…ØªØªØ§Ù„ÙŠØ©ØŒ Ù„ÙƒÙ† Physical frames ÙŠÙ…ÙƒÙ† Ø£Ù† ØªÙƒÙˆÙ† ÙÙŠ Ø£ÙŠ Ù…ÙƒØ§Ù†
â€¢ Easy to allocate/deallocate Pages</pre>
          </div>

          <h3>Page Size Trade-offs:</h3>

          <table>
            <thead>
              <tr>
                <th>Page Size</th>
                <th>Ø§Ù„Ù…Ø²Ø§ÙŠØ§</th>
                <th>Ø§Ù„Ø¹ÙŠÙˆØ¨</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Small (4 KB)</strong></td>
                <td>Less Internal Fragmentation<br>Fine-grained control</td>
                <td>Large Page Tables<br>More TLB misses</td>
              </tr>
              <tr>
                <td><strong>Large (2 MB, 1 GB)</strong></td>
                <td>Smaller Page Tables<br>Fewer TLB misses<br>Less overhead</td>
                <td>More Internal Fragmentation<br>Wasted space</td>
              </tr>
            </tbody>
          </table>

          <div class="info">
            <strong>ğŸ’¡ Modern Systems:</strong><br />
            â€¢ Default: 4 KB pages<br />
            â€¢ Support for Large Pages: 2 MB (Huge Pages), 1 GB (Giant Pages)<br />
            â€¢ Android: ÙŠØ³ØªØ®Ø¯Ù… 4 KB Ø¹Ø§Ø¯Ø©Ù‹ØŒ Ù…Ø¹ Ø¯Ø¹Ù… Transparent Huge Pages<br />
            â€¢ Large Pages Ù„Ù„Ù€: Database caches, Virtual machines, Large allocations
          </div>

          <hr />

          <h2>Page Tables: Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø³Ø­Ø±ÙŠØ© ğŸ—ºï¸</h2>

          <h3>Ù…Ø§ Ù‡Ùˆ Page TableØŸ</h3>

          <blockquote>
            <strong>Page Table:</strong> Ù‡ÙŠÙƒÙ„ Ø¨ÙŠØ§Ù†Ø§Øª ÙŠØ­ØªÙØ¸ Ø¨Ø§Ù„ØªØ±Ø¬Ù…Ø© Ù…Ù† Virtual Page Number Ø¥Ù„Ù‰ Physical Frame Number<br />
            <br />
            â€¢ ÙƒÙ„ Process Ù„Ù‡ Page Table Ø®Ø§Øµ Ø¨Ù‡<br />
            â€¢ ÙŠÙØ®Ø²Ù† ÙÙŠ RAM<br />
            â€¢ ÙŠÙØ¯Ø§Ø± Ø¨ÙˆØ§Ø³Ø·Ø© OS<br />
            â€¢ ÙŠÙØ³ØªØ®Ø¯Ù… Ø¨ÙˆØ§Ø³Ø·Ø© MMU Ù„Ù„ØªØ±Ø¬Ù…Ø©
          </blockquote>

          <h3>Simple Page Table (Single-Level):</h3>

          <div dir="ltr">
            <pre>Example: 32-bit system, 4 KB pages

Virtual Address Space: 4 GB = 2^32 bytes
Page Size: 4 KB = 2^12 bytes
Number of Pages: 2^32 / 2^12 = 2^20 = 1,048,576 pages

Page Table:
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ VPN  â”‚   PFN    â”‚Valid â”‚  R/W â”‚  X   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0    â”‚  0x0005  â”‚  1   â”‚  1   â”‚  1   â”‚ â† Code page (Executable)
â”‚ 1    â”‚  0x0003  â”‚  1   â”‚  1   â”‚  1   â”‚
â”‚ 2    â”‚  0x0012  â”‚  1   â”‚  1   â”‚  0   â”‚ â† Data page (No Execute)
â”‚ 3    â”‚  0x0020  â”‚  1   â”‚  1   â”‚  0   â”‚
â”‚ 4    â”‚    -     â”‚  0   â”‚  -   â”‚  -   â”‚ â† Not allocated
â”‚ 5    â”‚    -     â”‚  0   â”‚  -   â”‚  -   â”‚
â”‚ ...  â”‚   ...    â”‚ ...  â”‚ ...  â”‚ ...  â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜

Entry Size: 4 bytes (32 bits)
Total Size: 1,048,576 * 4 = 4 MB per Process!

Problem: 100 Processes = 400 MB just for Page Tables! ğŸ’°</pre>
          </div>

          <h3>Multi-Level Page Tables (Ø§Ù„Ø­Ù„ Ø§Ù„Ø°ÙƒÙŠ):</h3>

          <div dir="ltr">
            <pre>Two-Level Page Table (x86):

Virtual Address (32-bit):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Dir Index  â”‚ Table Indexâ”‚ Page Offset  â”‚
â”‚  10 bits   â”‚  10 bits   â”‚   12 bits    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Level 1: Page Directory
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Index â”‚  PT Address  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0   â”‚  0x1000      â”‚ â†’ Points to Page Table 0
â”‚  1   â”‚  0x2000      â”‚ â†’ Points to Page Table 1
â”‚  2   â”‚     -        â”‚ â†’ NULL (not allocated)
â”‚  3   â”‚     -        â”‚ â†’ NULL
â”‚ ...  â”‚    ...       â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
1024 entries = 4 KB

Level 2: Page Tables (only if needed!)
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Index â”‚     PFN      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0   â”‚  0x0005      â”‚
â”‚  1   â”‚  0x0003      â”‚
â”‚ ...  â”‚    ...       â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Advantage:
â€¢ Sparse allocation: ÙÙ‚Ø· Tables Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø© ØªÙØ®ØµØµ
â€¢ Typical process uses ~100 MB â†’ needs ~25 Page Tables
â€¢ 25 * 4 KB = 100 KB (vs 4 MB in single-level!)
â€¢ 40x reduction! âœ“</pre>
          </div>

          <h3>64-bit Systems (4-Level Page Tables):</h3>

          <div dir="ltr">
            <pre>x86-64 uses 4-Level Page Tables:

Virtual Address (48-bit used of 64-bit):
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ L4 â”‚ L3 â”‚ L2 â”‚ L1 â”‚ Page Offset  â”‚
â”‚ 9b â”‚ 9b â”‚ 9b â”‚ 9b â”‚   12 bits    â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Structure:
PML4 (Page Map Level 4)
  â””â”€â†’ PDPT (Page Directory Pointer Table)
       â””â”€â†’ PD (Page Directory)
            â””â”€â†’ PT (Page Table)
                 â””â”€â†’ Physical Frame

Why 4 levels?
â€¢ 64-bit = 16 EB (Exabytes) address space
â€¢ Can't have flat table (would be huge!)
â€¢ 4 levels allows sparse allocation
â€¢ Only allocate tables for used regions

Android (ARM64):
â€¢ Also uses 4-level page tables
â€¢ Supports 39-bit or 48-bit virtual addresses
â€¢ Configurable based on needs</pre>
          </div>

          <h3>Page Table Entry (PTE) Contents:</h3>

          <table>
            <thead>
              <tr>
                <th>Bit/Field</th>
                <th>Ø§Ù„ÙˆØµÙ</th>
                <th>Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>PFN</strong></td>
                <td>Physical Frame Number</td>
                <td>Ø£ÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ RAM</td>
              </tr>
              <tr>
                <td><strong>Valid</strong></td>
                <td>1 = ÙÙŠ RAMØŒ 0 = Ø¹Ù„Ù‰ Disk</td>
                <td>Ù„Ù„ÙƒØ´Ù Ø¹Ù† Page Faults</td>
              </tr>
              <tr>
                <td><strong>Read</strong></td>
                <td>Permission Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©</td>
                <td>Ø§Ù„Ø£Ù…Ø§Ù†</td>
              </tr>
              <tr>
                <td><strong>Write</strong></td>
                <td>Permission Ù„Ù„ÙƒØªØ§Ø¨Ø©</td>
                <td>Code pages = Read-Only</td>
              </tr>
              <tr>
                <td><strong>Execute</strong></td>
                <td>Permission Ù„Ù„ØªÙ†ÙÙŠØ°</td>
                <td>Data pages = No Execute (NX)</td>
              </tr>
              <tr>
                <td><strong>Dirty</strong></td>
                <td>1 = modified</td>
                <td>Ù„Ù„ÙƒØ´Ù Ø¹Ù† Pages Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©</td>
              </tr>
              <tr>
                <td><strong>Accessed</strong></td>
                <td>1 = recently used</td>
                <td>Page Replacement algorithms</td>
              </tr>
              <tr>
                <td><strong>User/Supervisor</strong></td>
                <td>Privilege level</td>
                <td>Kernel pages vs User pages</td>
              </tr>
            </tbody>
          </table>

          <hr />

          <h2>TLB: Cache Ù„Ù„ØªØ±Ø¬Ù…Ø© âš¡</h2>

          <h3>Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: Page Table ÙÙŠ RAM (Ø¨Ø·ÙŠØ¡!):</h3>

          <div dir="ltr">
            <pre>Without TLB:

Every Memory Access needs:
1. Load Virtual Address
2. Access Page Table in RAM â†’ 100 ns
3. Translate to Physical Address
4. Access actual data in RAM â†’ 100 ns
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total: 200 ns per access (2x slower!)

Example: 1 million accesses
â€¢ Without page tables: 100 ms
â€¢ With page tables (no TLB): 200 ms (2x slower!)
â†’ Performance penalty: 100%! ğŸ’°</pre>
          </div>

          <h3>Ø§Ù„Ø­Ù„: TLB (Translation Lookaside Buffer):</h3>

          <blockquote>
            <strong>TLB:</strong> Cache ØµØºÙŠØ± ÙˆØ³Ø±ÙŠØ¹ Ø¬Ø¯Ø§Ù‹ ÙŠØ­ÙØ¸ Ø¢Ø®Ø± Ø§Ù„ØªØ±Ø¬Ù…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©<br />
            â€¢ Size: 64-2048 entries Ù†Ù…ÙˆØ°Ø¬ÙŠØ§Ù‹<br />
            â€¢ Access Time: ~1 CPU cycle<br />
            â€¢ Hit Rate: 95-99% Ù†Ù…ÙˆØ°Ø¬ÙŠØ§Ù‹<br />
            â€¢ Per-CPU (ÙƒÙ„ Core Ù„Ù‡ TLB Ø®Ø§Øµ)
          </blockquote>

          <h3>ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ TLBØŸ</h3>

          <div dir="ltr">
            <pre>Memory Access with TLB:

CPU: "Load from Virtual Address 0x00401234"
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Check TLB (Cache)                 â”‚
â”‚    VPN 0x00401 â†’ PFN?                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“
     â”œâ”€â†’ TLB Hit (95-99% of time):
     â”‚   â””â”€â†’ PFN = 0x08042 (from TLB)
     â”‚       â””â”€â†’ Physical Addr = 0x08042234
     â”‚           â””â”€â†’ Access RAM (100 ns)
     â”‚               Total: ~101 ns âœ“
     â”‚
     â””â”€â†’ TLB Miss (1-5% of time):
         â””â”€â†’ Walk Page Tables in RAM (100+ ns)
             â””â”€â†’ Find PFN = 0x08042
                 â””â”€â†’ Update TLB with this entry
                     â””â”€â†’ Physical Addr = 0x08042234
                         â””â”€â†’ Access RAM (100 ns)
                             Total: ~250 ns (slower)

Average with TLB:
â€¢ 98% hits: 98% * 101 ns = 99 ns
â€¢ 2% misses: 2% * 250 ns = 5 ns
â€¢ Total: 104 ns (vs 200 ns without TLB)
â†’ Performance gain: ~50%! âœ“</pre>
          </div>

          <h3>TLB Entry Structure:</h3>

          <div dir="ltr">
            <pre>TLB Entry:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚  VPN   â”‚ ASID â”‚   PFN    â”‚Perms â”‚Validâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚0x00401 â”‚  5   â”‚ 0x08042  â”‚ R/W  â”‚  1  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

Fields:
â€¢ VPN: Virtual Page Number (Tag)
â€¢ ASID: Address Space ID (Process ID)
â€¢ PFN: Physical Frame Number
â€¢ Perms: Permissions (R/W/X)
â€¢ Valid: Entry is valid

ASID Purpose:
â€¢ Avoid TLB flush on context switch!
â€¢ Each Process has unique ASID
â€¢ TLB can hold entries from multiple Processes
â€¢ Example:
  Process A (ASID=1): VPN 0x100 â†’ PFN 0x500
  Process B (ASID=2): VPN 0x100 â†’ PFN 0x600
  Both in TLB simultaneously âœ“</pre>
          </div>

          <h3>TLB Management:</h3>

          <div class="warning">
            <strong>âš ï¸ TLB ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ«Ù‡ Ø¹Ù†Ø¯:</strong><br />
            <br />
            <strong>1. Context Switch (Process Switch):</strong><br />
            â€¢ Option A: Flush TLB ØªÙ…Ø§Ù…Ø§Ù‹ (costly!)<br />
            â€¢ Option B: Ø§Ø³ØªØ®Ø¯Ø§Ù… ASID (better!)<br />
            <br />
            <strong>2. Page Table Changes:</strong><br />
            â€¢ OS ÙŠØ¹Ø¯Ù‘Ù„ Page Table â†’ ÙŠØ¬Ø¨ invalidate TLB entry<br />
            â€¢ ÙˆØ¥Ù„Ø§: Stale translation! (Bug Ø®Ø·ÙŠØ±)<br />
            <br />
            <strong>3. Memory Protection Changes:</strong><br />
            â€¢ ØªØºÙŠÙŠØ± Permissions â†’ TLB entry Ù‚Ø¯ÙŠÙ…<br />
            <br />
            <strong>â†’ TLB Shootdown ÙÙŠ Multi-Core:</strong><br />
            CPU 0 ÙŠØ¹Ø¯Ù„ Page Table â†’ ÙŠØ¬Ø¨ Ø¥Ø¨Ù„Ø§Øº CPU 1, 2, 3...<br />
            ÙƒÙ„ CPUs ØªØ¹Ù…Ù„ TLB flush â†’ expensive!
          </div>

          <hr />

          <h2>Page Faults: Ø¹Ù†Ø¯Ù…Ø§ Ù„Ø§ Ù†Ø¬Ø¯ Ø§Ù„ØµÙØ­Ø© ğŸš¨</h2>

          <h3>Ù…Ø§ Ù‡Ùˆ Page FaultØŸ</h3>

          <blockquote>
            <strong>Page Fault:</strong> Ø¹Ù†Ø¯Ù…Ø§ Process ÙŠØ­Ø§ÙˆÙ„ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù€ Virtual Page ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Physical RAM<br />
            <br />
            <strong>Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨:</strong><br />
            1. Page Ø¹Ù„Ù‰ Disk (Swapped out)<br />
            2. Page Ù„Ù… ÙŠÙØ®ØµØµ Ø¨Ø¹Ø¯ (Lazy Allocation)<br />
            3. Invalid Access (Segmentation Fault!)<br />
            4. Copy-on-Write
          </blockquote>

          <h3>ÙƒÙŠÙ ÙŠÙØ¹Ø§Ù„Ø¬ Page FaultØŸ</h3>

          <div dir="ltr">
            <pre>Page Fault Handling:

1. CPU: "Load from 0x00401234"
   â””â”€â†’ MMU: Check Page Table
       â””â”€â†’ Valid bit = 0 â†’ PAGE FAULT! ğŸ’¥

2. CPU: Trap to OS (Exception)
   â””â”€â†’ Save Process state
       â””â”€â†’ Enter Kernel Mode

3. OS Page Fault Handler:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ A. Check if valid access?            â”‚
   â”‚    â””â”€â†’ Yes â†’ Continue                â”‚
   â”‚    â””â”€â†’ No â†’ SEGFAULT! Kill process   â”‚
   â”‚                                      â”‚
   â”‚ B. Is page on disk?                  â”‚
   â”‚    â””â”€â†’ Find free frame in RAM        â”‚
   â”‚        â””â”€â†’ If no free frame:         â”‚
   â”‚            â””â”€â†’ Page Replacement!     â”‚
   â”‚                (evict old page)      â”‚
   â”‚        â””â”€â†’ Read page from Disk       â”‚
   â”‚            (1-10 ms - very slow!)    â”‚
   â”‚        â””â”€â†’ Update Page Table         â”‚
   â”‚        â””â”€â†’ Invalidate TLB            â”‚
   â”‚                                      â”‚
   â”‚ C. Return to Process                 â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4. CPU: Retry the instruction
   â””â”€â†’ Now page is in RAM â†’ Success! âœ“

Total Time:
â€¢ Major Page Fault (from disk): 1-10 ms (1,000,000 ns!)
â€¢ Minor Page Fault (already in RAM, just not mapped): 1-10 Âµs
â€¢ Normal Memory Access: 100 ns

â†’ Page Fault is 10,000x - 100,000x slower! ğŸ’°</pre>
          </div>

          <h3>Ø£Ù†ÙˆØ§Ø¹ Page Faults:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ù†ÙˆØ¹</th>
                <th>Ø§Ù„Ø³Ø¨Ø¨</th>
                <th>Ø§Ù„ØªÙƒÙ„ÙØ©</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Minor (Soft)</strong></td>
                <td>Page ÙÙŠ RAM Ù„ÙƒÙ† ØºÙŠØ± mapped<br>Ù…Ø«Ù„: Copy-on-Write</td>
                <td>1-10 Âµs (Ø³Ø±ÙŠØ¹ Ù†Ø³Ø¨ÙŠØ§Ù‹)</td>
              </tr>
              <tr>
                <td><strong>Major (Hard)</strong></td>
                <td>Page Ø¹Ù„Ù‰ DiskØŒ ÙŠØ­ØªØ§Ø¬ I/O</td>
                <td>1-10 ms (Ø¨Ø·ÙŠØ¡ Ø¬Ø¯Ø§Ù‹!)</td>
              </tr>
              <tr>
                <td><strong>Invalid</strong></td>
                <td>Access ØºÙŠØ± Ù‚Ø§Ù†ÙˆÙ†ÙŠ</td>
                <td>N/A (Crash!)</td>
              </tr>
            </tbody>
          </table>

          <h3>Page Replacement Algorithms:</h3>

          <div dir="ltr">
            <pre>When RAM is full, which page to evict?

1. FIFO (First-In, First-Out):
   â€¢ Evict oldest page
   â€¢ Simple, but not optimal
   â€¢ Rarely used

2. LRU (Least Recently Used):
   â€¢ Evict page not used for longest time
   â€¢ Optimal for most workloads âœ“
   â€¢ Expensive to implement perfectly

3. Clock (Second Chance):
   â€¢ Approximation of LRU
   â€¢ Uses "Accessed" bit in PTE
   â€¢ Efficient and practical âœ“
   â€¢ Used in Linux/Android

4. LFU (Least Frequently Used):
   â€¢ Evict page used least often
   â€¢ Good for some workloads
   â€¢ Complex to implement

Linux/Android uses: Clock + Additional heuristics
â€¢ Clean pages (not modified) evicted first âœ“
â€¢ Dirty pages (modified) written to disk first
â€¢ Executables vs Data prioritized differently</pre>
          </div>

          <h3>Copy-on-Write (COW):</h3>

          <div dir="ltr">
            <pre>Smart Optimization:

fork() creates new process:
â€¢ Naive: Copy all pages â†’ slow, wasteful
â€¢ COW: Share pages until write!

Example:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Parent Process:                       â”‚
â”‚ Page 1: Code (Read-Only) â†’ Frame A   â”‚
â”‚ Page 2: Data (R/W) â†’ Frame B         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“ fork()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Child Process:                        â”‚
â”‚ Page 1: Code â†’ Frame A  (shared!)     â”‚ â† Same frame!
â”‚ Page 2: Data â†’ Frame B  (shared!)     â”‚ â† Same frame!
â”‚                                       â”‚
â”‚ Both pages marked: Copy-on-Write      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Child tries to write to Page 2:
â””â”€â†’ Page Fault! (write to COW page)
    â””â”€â†’ OS: Allocate new Frame C
        â””â”€â†’ Copy Frame B â†’ Frame C
            â””â”€â†’ Update Child's Page Table:
                Page 2 â†’ Frame C (writable)
            â””â”€â†’ Parent still uses Frame B
                â””â”€â†’ Isolation restored! âœ“

Benefit:
â€¢ Fast fork() (no copying!)
â€¢ Memory efficient (share read-only pages)
â€¢ Copy only when needed (lazy)</pre>
          </div>

          <hr />

          <h2>Memory Allocation Strategies ğŸ¯</h2>

          <h3>Heap Allocation (malloc/new):</h3>

          <div dir="ltr">
            <pre>User calls: malloc(1024) // 1 KB

Heap Allocator (libc):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Check free lists                  â”‚
â”‚    â””â”€â†’ Small allocations: use bins   â”‚
â”‚    â””â”€â†’ Large allocations: mmap()     â”‚
â”‚                                      â”‚
â”‚ 2. Find suitable block                â”‚
â”‚    Strategies:                       â”‚
â”‚    â€¢ First Fit: first block >= size  â”‚
â”‚    â€¢ Best Fit: smallest block >= sizeâ”‚
â”‚    â€¢ Worst Fit: largest block        â”‚
â”‚                                      â”‚
â”‚ 3. Split block if too large          â”‚
â”‚    â””â”€â†’ Return 1 KB, keep rest free   â”‚
â”‚                                      â”‚
â”‚ 4. Return pointer to user            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Free List Structure:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Free   â”‚ Used   â”‚ Free   â”‚ Used   â”‚
â”‚ 8 KB   â”‚ 4 KB   â”‚ 16 KB  â”‚ 2 KB   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Problems:
â€¢ Fragmentation: free space scattered
â€¢ Coalescing: merge adjacent free blocks
â€¢ Overhead: metadata for each block</pre>
          </div>

          <h3>Memory Allocators:</h3>

          <table>
            <thead>
              <tr>
                <th>Allocator</th>
                <th>Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…</th>
                <th>Ø§Ù„Ù…Ø²Ø§ÙŠØ§</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>ptmalloc (glibc)</strong></td>
                <td>Linux default</td>
                <td>General purposeØŒ thread-safe</td>
              </tr>
              <tr>
                <td><strong>jemalloc</strong></td>
                <td>Firefox, FreeBSD</td>
                <td>Ø£Ø¯Ø§Ø¡ Ø¹Ø§Ù„ÙŠØŒ low fragmentation</td>
              </tr>
              <tr>
                <td><strong>tcmalloc</strong></td>
                <td>Google Chrome</td>
                <td>Ø³Ø±ÙŠØ¹ Ø¬Ø¯Ø§Ù‹ Ù„Ù„Ù€ multi-threading</td>
              </tr>
              <tr>
                <td><strong>Scudo</strong></td>
                <td>Android (native)</td>
                <td>Security-focused, hardened</td>
              </tr>
            </tbody>
          </table>

          <h3>Slab Allocation (Kernel):</h3>

          <div dir="ltr">
            <pre>Kernel needs many objects of same size:
â€¢ Process descriptors (task_struct)
â€¢ File descriptors (file)
â€¢ Network buffers (sk_buff)
â€¢ inode structures

Slab Allocator:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Cache for "task_struct" (2 KB each) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Slab 1: [â–ˆâ–ˆâ–ˆâ–ˆ][â–ˆâ–ˆâ–ˆâ–ˆ][â–ˆâ–ˆâ–ˆâ–ˆ][    ]    â”‚ â† 3 used, 1 free
â”‚ Slab 2: [â–ˆâ–ˆâ–ˆâ–ˆ][â–ˆâ–ˆâ–ˆâ–ˆ][â–ˆâ–ˆâ–ˆâ–ˆ][â–ˆâ–ˆâ–ˆâ–ˆ]    â”‚ â† Full
â”‚ Slab 3: [    ][    ][    ][    ]    â”‚ â† Empty
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Advantages:
â€¢ No fragmentation (fixed size)
â€¢ Fast allocation (O(1))
â€¢ Good cache locality
â€¢ Pre-initialized objects

Android uses: SLUB (improved version)</pre>
          </div>

          <hr />

          <h2>Memory ÙÙŠ Android ØªØ­Ø¯ÙŠØ¯Ù‹Ø§ ğŸ“±</h2>

          <h3>Android Memory Architecture:</h3>

          <div dir="ltr">
            <pre>Android Memory Layers:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Java/Kotlin Objects (Dalvik/ART Heap)   â”‚
â”‚    â€¢ Managed by Garbage Collector          â”‚
â”‚    â€¢ Automatic memory management           â”‚
â”‚    â€¢ Typical: 64-512 MB per app            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Native Heap (C/C++)                      â”‚
â”‚    â€¢ malloc/free                            â”‚
â”‚    â€¢ Manual memory management              â”‚
â”‚    â€¢ Bitmaps, NDK code, JNI                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Process Memory (Linux)                   â”‚
â”‚    â€¢ Code, Data, Stack                      â”‚
â”‚    â€¢ Shared Libraries                       â”‚
â”‚    â€¢ Kernel structures                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Physical RAM (Hardware)                  â”‚
â”‚    â€¢ Managed by Linux Kernel               â”‚
â”‚    â€¢ Shared across all processes           â”‚
â”‚    â€¢ Typical: 4-16 GB                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <h3>Android Memory Limits:</h3>

          <div dir="ltr">
            <pre>Per-App Memory Limits:

Low-end device (2 GB RAM):
â€¢ Heap Limit: 64-128 MB per app
â€¢ Large Heap: 256 MB (with android:largeHeap="true")

Mid-range device (4-6 GB RAM):
â€¢ Heap Limit: 192-384 MB per app
â€¢ Large Heap: 512 MB

High-end device (8+ GB RAM):
â€¢ Heap Limit: 384-512 MB per app
â€¢ Large Heap: 768 MB - 1 GB

Check current limit:
val runtime = Runtime.getRuntime()
val maxMemory = runtime.maxMemory() / (1024 * 1024)
Log.d("Memory", "Max: ${maxMemory} MB")

Why limits?
â€¢ Prevent single app hogging all RAM
â€¢ Fairness across apps
â€¢ System stability
â€¢ Battery life (less memory = less power)</pre>
          </div>

          <h3>Android Low Memory Killer (LMK):</h3>

          <div dir="ltr">
            <pre>When RAM is low, Android kills processes:

Process Priority (OOM Adj Score):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ -1000: System (never killed)         â”‚
â”‚ -900:  Persistent                    â”‚
â”‚ -800:  Foreground App                â”‚ â† Currently visible
â”‚ -700:  Perceptible                   â”‚
â”‚ -600:  Visible                       â”‚
â”‚ -100:  Service                       â”‚
â”‚ 0-100: Home                          â”‚
â”‚ 200+:  Cached Apps                   â”‚ â† First to be killed
â”‚ 900+:  Empty                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Decision Process:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Free RAM < 100 MB? (threshold)       â”‚
â”‚ â””â”€â†’ Yes:                             â”‚
â”‚     1. Sort processes by OOM Adj     â”‚
â”‚     2. Kill highest OOM Adj first    â”‚
â”‚     3. Reclaim memory                â”‚
â”‚     4. Repeat until RAM > threshold  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example:
Free RAM: 80 MB (low!)
â”œâ”€â†’ Kill Background App A (OOM=900) â†’ Free 150 MB
â”‚   â””â”€â†’ Now Free RAM = 230 MB âœ“
â”œâ”€â†’ Stop (threshold met)

User returns to App A:
â””â”€â†’ Process killed â†’ Cold start (slow)
    â””â”€â†’ onCreate() called
        â””â”€â†’ Restore state from savedInstanceState</pre>
          </div>

          <h3>Memory Types ÙÙŠ Android:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ù†ÙˆØ¹</th>
                <th>Ø§Ù„ÙˆØµÙ</th>
                <th>Ø§Ù„Ù…Ø«Ø§Ù„</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Java Heap</strong></td>
                <td>Objects Ø§Ù„Ù…ÙØ¯Ø§Ø±Ø© Ø¨ÙˆØ§Ø³Ø·Ø© GC</td>
                <td>String, ArrayList, ViewModel</td>
              </tr>
              <tr>
                <td><strong>Native Heap</strong></td>
                <td>C/C++ allocations</td>
                <td>Bitmap pixels, NDK, OpenGL</td>
              </tr>
              <tr>
                <td><strong>Stack</strong></td>
                <td>Local variables, call frames</td>
                <td>int x = 5; ÙÙŠ function</td>
              </tr>
              <tr>
                <td><strong>Code</strong></td>
                <td>Dalvik bytecode, native libs</td>
                <td>.dex files, .so libraries</td>
              </tr>
              <tr>
                <td><strong>Graphics</strong></td>
                <td>GPU memory, surfaces</td>
                <td>View rendering, textures</td>
              </tr>
              <tr>
                <td><strong>Ashmem</strong></td>
                <td>Anonymous shared memory</td>
                <td>Binder transactions, IPC</td>
              </tr>
            </tbody>
          </table>

          <hr />

          <h2>Garbage Collection ğŸ—‘ï¸</h2>

          <h3>Ù„Ù…Ø§Ø°Ø§ Ù†Ø­ØªØ§Ø¬ GCØŸ</h3>

          <blockquote>
            <strong>Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:</strong> Manual memory management (C/C++) Ø®Ø·ÙŠØ±:<br />
            â€¢ Memory Leaks: Ù†Ø³ÙŠØª free() â†’ Ø°Ø§ÙƒØ±Ø© Ù…Ù‡Ø¯ÙˆØ±Ø©<br />
            â€¢ Dangling Pointers: free() Ù…Ø±ØªÙŠÙ† â†’ Crash<br />
            â€¢ Use-After-Free: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨Ø¹Ø¯ free() â†’ Security bug<br />
            <br />
            <strong>Ø§Ù„Ø­Ù„:</strong> Garbage Collector<br />
            â€¢ ØªÙ„Ù‚Ø§Ø¦ÙŠ: ÙŠØ­Ø°Ù Objects ØºÙŠØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©<br />
            â€¢ Ø¢Ù…Ù†: Ù„Ø§ Dangling pointers<br />
            â€¢ Ø¨Ø·ÙŠØ¡ Ù†Ø³Ø¨ÙŠØ§Ù‹: ÙŠØ­ØªØ§Ø¬ CPU time
          </blockquote>

          <h3>ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ GC ÙÙŠ Android (ART)ØŸ</h3>

          <div dir="ltr">
            <pre>ART Garbage Collector:

Heap Structure:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Young Generation (Nursery):            â”‚
â”‚ â€¢ Objects Ø­Ø¯ÙŠØ«Ø© Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡                â”‚
â”‚ â€¢ Ø­Ø¬Ù… ØµØºÙŠØ± (~8 MB)                     â”‚
â”‚ â€¢ GC Ù…ØªÙƒØ±Ø± (minor GC)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“ (objects survive)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Old Generation:                        â”‚
â”‚ â€¢ Objects Ù‚Ø¯ÙŠÙ…Ø© (survived multiple GC) â”‚
â”‚ â€¢ Ø­Ø¬Ù… ÙƒØ¨ÙŠØ± (~100+ MB)                  â”‚
â”‚ â€¢ GC Ù†Ø§Ø¯Ø± (major GC)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

GC Algorithm (Concurrent Mark-Sweep):

Phase 1: Mark (with pauses)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Pause threads briefly (~2-5 ms)   â”‚
â”‚ 2. Mark "roots" (stack, globals)     â”‚
â”‚ 3. Resume threads                    â”‚
â”‚ 4. Concurrent mark (no pause!)       â”‚
â”‚    â””â”€â†’ Scan heap, mark reachable    â”‚
â”‚        objects (20-50 ms)            â”‚
â”‚ 5. Pause again briefly (~2-5 ms)     â”‚
â”‚    â””â”€â†’ Re-scan modified objects      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Phase 2: Sweep
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Concurrent sweep (no pause!)      â”‚
â”‚    â””â”€â†’ Free unmarked objects         â”‚
â”‚        (10-30 ms)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total Pause Time: ~5-10 ms
Total GC Time: ~30-100 ms

Why "Concurrent"?
â€¢ Most GC work happens while app runs! âœ“
â€¢ Short pauses (< 10ms) â†’ no visible lag
â€¢ Old GC (Dalvik): 50-200 ms pause â†’ Jank!</pre>
          </div>

          <h3>GC Triggers:</h3>

          <div dir="ltr">
            <pre>When does GC run?

1. Allocation Failure:
   â€¢ App tries to allocate object
   â€¢ Heap full â†’ GC runs
   â€¢ If still full â†’ OutOfMemoryError!

2. Explicit call:
   System.gc()  // Not recommended!
   // Hint only, GC may ignore

3. Background GC:
   â€¢ App goes to background
   â€¢ Preemptive GC to free memory
   â€¢ Prepare for possible kill

4. Low Memory:
   â€¢ System broadcasts low memory
   â€¢ onTrimMemory(TRIM_MEMORY_RUNNING_LOW)
   â€¢ Apps should free caches

5. Heap Growth:
   â€¢ Heap grows beyond threshold
   â€¢ Trigger GC before getting too large</pre>
          </div>

          <h3>GC Performance Impact:</h3>

          <div class="warning">
            <strong>âš ï¸ Ù…Ø´Ø§ÙƒÙ„ GC Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©:</strong><br />
            <br />
            <strong>1. Allocation Churn:</strong><br />
            â€¢ Ø¥Ù†Ø´Ø§Ø¡/Ø­Ø°Ù Objects ÙƒØ«ÙŠØ±Ø© Ø¨Ø³Ø±Ø¹Ø©<br />
            â€¢ Ù…Ø«Ø§Ù„: Allocate ÙÙŠ onDraw() loop â†’ GC ÙƒÙ„ frame!<br />
            â€¢ Ø§Ù„Ø­Ù„: Object pooling, reuse objects<br />
            <br />
            <strong>2. Memory Leaks:</strong><br />
            â€¢ Objects Ù„Ø§ ØªÙØ­Ø°Ù Ø±ØºÙ… Ø¹Ø¯Ù… Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§<br />
            â€¢ Ù…Ø«Ø§Ù„: Activity leak ÙÙŠ static reference<br />
            â€¢ Ø§Ù„Ù†ØªÙŠØ¬Ø©: Heap ÙŠÙƒØ¨Ø±ØŒ GC ÙŠØªØ¨Ø§Ø·Ø£<br />
            <br />
            <strong>3. Large Object Allocations:</strong><br />
            â€¢ Bitmaps, large arrays<br />
            â€¢ ÙŠÙ…Ù„Ø£ÙˆÙ† Heap Ø¨Ø³Ø±Ø¹Ø© â†’ GC Ù…ØªÙƒØ±Ø±<br />
            â€¢ Ø§Ù„Ø­Ù„: Native heap, streaming, downsampling
          </div>

          <hr />

          <h2>Memory Leaks ÙˆÙƒÙŠÙÙŠØ© ØªØ¬Ù†Ø¨Ù‡Ø§ ğŸš°</h2>

          <h3>Ù…Ø§ Ù‡Ùˆ Memory LeakØŸ</h3>

          <blockquote>
            <strong>Memory Leak:</strong> Object Ù„Ø§ ÙŠØ²Ø§Ù„ Ù„Ù‡ referenceØŒ Ù„ÙƒÙ†Ù‡ ØºÙŠØ± Ù…Ø³ØªØ®Ø¯Ù… ÙØ¹Ù„ÙŠØ§Ù‹<br />
            <br />
            â€¢ GC Ù„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ Ø­Ø°ÙÙ‡ (Ù„Ù‡ reference!)<br />
            â€¢ ÙŠØ¨Ù‚Ù‰ ÙÙŠ Heap Ù„Ù„Ø£Ø¨Ø¯<br />
            â€¢ Heap ÙŠÙƒØ¨Ø± ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹<br />
            â€¢ ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©: OutOfMemoryError!
          </blockquote>

          <h3>Ø£Ù…Ø«Ù„Ø© Ø´Ø§Ø¦Ø¹Ø© Ù„Ù€ Memory Leaks:</h3>

          <h4>Leak 1: Static Reference Ù„Ù€ Activity:</h4>

          <div dir="ltr">
            <pre>// âŒ Memory Leak!
class MainActivity : AppCompatActivity() {
    companion object {
        var instance: MainActivity? = null  // Static reference!
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        instance = this  // âŒ Leak!
    }
}

Problem:
â€¢ User rotates screen
â€¢ Android destroys old Activity
â€¢ Creates new Activity
â€¢ But static reference still points to OLD Activity!
â€¢ OLD Activity can't be garbage collected
â€¢ Leak = 50-100 MB per rotation!

// âœ… Fix: Don't use static references to Activity!
// Use Application Context if needed:
class MyApp : Application() {
    companion object {
        lateinit var instance: MyApp  // OK (Application never destroyed)
    }
    
    override fun onCreate() {
        super.onCreate()
        instance = this
    }
}</pre>
          </div>

          <h4>Leak 2: Anonymous Inner Class:</h4>

          <div dir="ltr">
            <pre>// âŒ Memory Leak!
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        thread {
            Thread.sleep(10000)  // 10 seconds
            runOnUiThread {
                // This lambda holds reference to Activity!
                textView.text = "Done"
            }
        }
        
        // User presses back after 1 second
        // Activity should be destroyed
        // But thread keeps it alive for 10 seconds!
    }
}

// âœ… Fix: Use WeakReference
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        val activityRef = WeakReference(this)
        
        thread {
            Thread.sleep(10000)
            
            activityRef.get()?.runOnUiThread {
                textView.text = "Done"
            }
            // If Activity destroyed, activityRef.get() = null âœ“
        }
    }
}

// âœ… Ø£ÙØ¶Ù„: Use Coroutines + Lifecycle
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            delay(10000)
            textView.text = "Done"
        }
        // Automatically cancelled when Activity destroyed! âœ“
    }
}</pre>
          </div>

          <h4>Leak 3: Listener Ù„Ù… ÙŠÙÙ„ØºÙ‰:</h4>

          <div dir="ltr">
            <pre>// âŒ Memory Leak!
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Register listener
        SomeGlobalManager.addListener(object : Listener {
            override fun onEvent() {
                updateUI()  // References Activity!
            }
        })
        
        // âŒ Never removed! Manager keeps reference forever!
    }
}

// âœ… Fix: Remove listener in onDestroy
class MainActivity : AppCompatActivity() {
    private val listener = object : Listener {
        override fun onEvent() {
            updateUI()
        }
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        SomeGlobalManager.addListener(listener)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        SomeGlobalManager.removeListener(listener)  // âœ“ Clean up!
    }
}</pre>
          </div>

          <h4>Leak 4: Bitmap Ù„Ù… ÙŠÙØ­Ø±Ø±:</h4>

          <div dir="ltr">
            <pre>// âŒ Memory Leak!
class ImageActivity : AppCompatActivity() {
    private var largeBitmap: Bitmap? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Load 10 MB image
        largeBitmap = BitmapFactory.decodeFile("/sdcard/huge.jpg")
        imageView.setImageBitmap(largeBitmap)
    }
    
    // âŒ Activity destroyed, but bitmap still in memory!
}

// âœ… Fix: Recycle bitmap in onDestroy
class ImageActivity : AppCompatActivity() {
    private var largeBitmap: Bitmap? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        largeBitmap = BitmapFactory.decodeFile("/sdcard/huge.jpg")
        imageView.setImageBitmap(largeBitmap)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        largeBitmap?.recycle()  // âœ“ Free native memory!
        largeBitmap = null
    }
}

// âœ… Ø£ÙØ¶Ù„: Use Glide/Coil (ÙŠØ¯ÙŠØ±ÙˆÙ† Memory ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹)
Glide.with(this)
    .load("/sdcard/huge.jpg")
    .into(imageView)
// Glide handles lifecycle automatically! âœ“</pre>
          </div>

          <h3>Ø£Ø¯ÙˆØ§Øª ÙƒØ´Ù Memory Leaks:</h3>

          <div dir="ltr">
            <pre>1. Android Studio Memory Profiler:
   â€¢ View â†’ Tool Windows â†’ Profiler
   â€¢ Memory tab
   â€¢ Heap Dump â†’ Analyze
   â€¢ Look for: Activity instances > 1

2. LeakCanary (Library):
   dependencies {
       debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.12'
   }
   
   // Automatically detects leaks in debug builds!
   // Shows notification with leak trace âœ“

3. Manual Heap Dump:
   â€¢ Trigger GC several times
   â€¢ Dump heap
   â€¢ Analyze with Memory Analyzer Tool (MAT)
   â€¢ Search for Activity, Fragment, ViewModel</pre>
          </div>

          <hr />

          <h2>Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ© Ù…Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ ğŸ’¡</h2>

          <h3>Ù…Ø«Ø§Ù„ 1: Image Gallery Performance</h3>

          <div dir="ltr">
            <pre>// âŒ Ø³ÙŠØ¦: Load ÙƒÙ„ Images ÙÙŠ Memory
class GalleryActivity : AppCompatActivity() {
    private val images = mutableListOf<Bitmap>()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Load 1000 images (10 GB!)
        imageFiles.forEach { file ->
            val bitmap = BitmapFactory.decodeFile(file.path)
            images.add(bitmap)  // âŒ OutOfMemoryError!
        }
    }
}


// âœ… Ø¬ÙŠØ¯: Pagination + LRU Cache
class GalleryActivity : AppCompatActivity() {
    private val cache = LruCache<String, Bitmap>(
        (Runtime.getRuntime().maxMemory() / 8).toInt()  // 12.5% of heap
    )
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        recyclerView.adapter = GalleryAdapter()
    }
    
    inner class GalleryAdapter : RecyclerView.Adapter<ViewHolder>() {
        override fun onBindViewHolder(holder: ViewHolder, position: Int) {
            val file = imageFiles[position]
            
            // Check cache first
            val cached = cache.get(file.path)
            if (cached != null) {
                holder.imageView.setImageBitmap(cached)
                return
            }
            
            // Load in background
            lifecycleScope.launch(Dispatchers.IO) {
                val bitmap = decodeSampledBitmap(
                    file.path,
                    holder.imageView.width,
                    holder.imageView.height
                )
                
                cache.put(file.path, bitmap)
                
                withContext(Dispatchers.Main) {
                    holder.imageView.setImageBitmap(bitmap)
                }
            }
        }
    }
}

Benefits:
â€¢ Only loads visible images âœ“
â€¢ Downsamples to screen size âœ“
â€¢ Caches decoded bitmaps âœ“
â€¢ LRU evicts old images âœ“
â€¢ Memory usage: ~50 MB (vs 10 GB!)</pre>
          </div>

          <h3>Ù…Ø«Ø§Ù„ 2: Database Query Optimization</h3>

          <div dir="ltr">
            <pre>// âŒ Ø³ÙŠØ¦: Load ÙƒÙ„ Database ÙÙŠ Memory
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsers(): List<User>  // âŒ Load 1 million users!
}

class UserRepository(private val dao: UserDao) {
    fun getUsers(): List<User> {
        return dao.getAllUsers()  // âŒ OutOfMemoryError!
    }
}


// âœ… Ø¬ÙŠØ¯: Pagination
@Dao
interface UserDao {
    @Query("SELECT * FROM users LIMIT :limit OFFSET :offset")
    fun getUsersPage(limit: Int, offset: Int): List<User>
    
    // Or use Paging 3:
    @Query("SELECT * FROM users")
    fun getUsersPaged(): PagingSource<Int, User>
}

class UserRepository(private val dao: UserDao) {
    fun getUsers(): Flow<PagingData<User>> {
        return Pager(
            config = PagingConfig(pageSize = 50),
            pagingSourceFactory = { dao.getUsersPaged() }
        ).flow
    }
}

// ViewModel
class UserViewModel(private val repo: UserRepository) : ViewModel() {
    val users: Flow<PagingData<User>> = repo.getUsers()
        .cachedIn(viewModelScope)
}

Benefits:
â€¢ Only loads 50 users at a time âœ“
â€¢ Automatic loading on scroll âœ“
â€¢ Memory-efficient âœ“
â€¢ Smooth scrolling âœ“</pre>
          </div>

          <h3>Ù…Ø«Ø§Ù„ 3: Bitmap Pooling</h3>

          <div dir="ltr">
            <pre>// Reuse Bitmap objects (avoid allocation churn)

class BitmapPool {
    private val pool = mutableListOf<Bitmap>()
    private val maxSize = 10
    
    @Synchronized
    fun get(width: Int, height: Int): Bitmap {
        // Find reusable bitmap
        val index = pool.indexOfFirst { bitmap ->
            bitmap.width >= width &&
            bitmap.height >= height &&
            !bitmap.isRecycled
        }
        
        return if (index >= 0) {
            pool.removeAt(index)  // Reuse! âœ“
        } else {
            Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
        }
    }
    
    @Synchronized
    fun put(bitmap: Bitmap) {
        if (pool.size < maxSize && !bitmap.isRecycled) {
            pool.add(bitmap)  // Return to pool âœ“
        } else {
            bitmap.recycle()  // Pool full, recycle
        }
    }
}

// Usage:
val pool = BitmapPool()

fun processImages() {
    imageFiles.forEach { file ->
        val bitmap = pool.get(1024, 1024)  // Reuse!
        
        try {
            // Decode into reused bitmap
            decodeIntoBitmap(file, bitmap)
            processBitmap(bitmap)
        } finally {
            pool.put(bitmap)  // Return to pool
        }
    }
}

Benefits:
â€¢ Reduces GC pressure (no new allocations)
â€¢ Faster (reuse existing memory)
â€¢ Lower memory peak (fixed pool size)

Note: Glide/Coil do this automatically! âœ“</pre>
          </div>

          <hr />

          <h2>Ø§Ù„Ø®Ù„Ø§ØµØ© ÙˆØ§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ğŸ“</h2>

          <h3>Ù…Ù„Ø®Øµ Memory Management:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ù…ÙÙ‡ÙˆÙ…</th>
                <th>Ø§Ù„ÙˆØµÙ</th>
                <th>Ø§Ù„ÙØ§Ø¦Ø¯Ø©</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Virtual Memory</strong></td>
                <td>ÙˆÙ‡Ù… Ù…Ø³Ø§Ø­Ø© ÙƒØ¨ÙŠØ±Ø© Ø®Ø§ØµØ©</td>
                <td>Isolation, Simplicity</td>
              </tr>
              <tr>
                <td><strong>Paging</strong></td>
                <td>ØªÙ‚Ø³ÙŠÙ… Ù„Ù€ Pages (4 KB)</td>
                <td>No Fragmentation</td>
              </tr>
              <tr>
                <td><strong>Page Tables</strong></td>
                <td>ØªØ±Ø¬Ù…Ø© Virtual â†’ Physical</td>
                <td>Mapping, Permissions</td>
              </tr>
              <tr>
                <td><strong>TLB</strong></td>
                <td>Cache Ù„Ù„ØªØ±Ø¬Ù…Ø©</td>
                <td>Performance (50% faster)</td>
              </tr>
              <tr>
                <td><strong>Page Fault</strong></td>
                <td>Page ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ RAM</td>
                <td>Demand paging</td>
              </tr>
              <tr>
                <td><strong>GC</strong></td>
                <td>ØªÙ„Ù‚Ø§Ø¦ÙŠ memory management</td>
                <td>Safety, Convenience</td>
              </tr>
            </tbody>
          </table>

          <h3>Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©:</h3>

          <div dir="ltr">
            <pre>âœ“ Virtual Memory = ÙˆÙ‡Ù… Ù„ÙƒÙ„ Process
âœ“ Physical Memory = Ø§Ù„ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯
âœ“ MMU ÙŠØªØ±Ø¬Ù… Ø¨ÙŠÙ†Ù‡Ù…Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
âœ“ Paging: 4 KB pagesØŒ Ù„Ø§ Fragmentation
âœ“ TLB: Cache ÙŠØ³Ø±Ù‘Ø¹ Ø§Ù„ØªØ±Ø¬Ù…Ø© (~99% hit rate)
âœ“ Page Fault = Ø¨Ø·ÙŠØ¡ Ø¬Ø¯Ø§Ù‹ (1-10 ms)
âœ“ GC = ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„ÙƒÙ† ÙŠØ­ØªØ§Ø¬ CPU

âœ“ Android: Per-app memory limits
âœ“ Leaks: References ØªÙ…Ù†Ø¹ GC
âœ“ WeakReference: Ù„Ù„Ù€ Caches
âœ“ Lifecycle: Ù†Ø¸Ù‘Ù ÙÙŠ onDestroy
âœ“ Profiler: Ø±Ø§Ù‚Ø¨ Memory Ø¯Ø§Ø¦Ù…Ø§Ù‹</pre>
          </div>

          <h3>Best Practices ÙÙŠ Android:</h3>

          <div class="success">
            <strong>âœ… Ø§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:</strong><br />
            <br />
            <strong>1. ØªØ¬Ù†Ø¨ Memory Leaks:</strong><br />
            â€¢ Ù„Ø§ Static references Ù„Ù€ Activity/Fragment<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… WeakReference Ù„Ù„Ù€ Caches<br />
            â€¢ Ù†Ø¸Ù‘Ù Listeners ÙÙŠ onDestroy<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… lifecycleScope Ù„Ù„Ù€ Coroutines<br />
            <br />
            <strong>2. Ù‚Ù„Ù„ Allocation Churn:</strong><br />
            â€¢ Ù„Ø§ ØªÙÙ†Ø´Ø¦ Objects ÙÙŠ loops<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… Object pooling<br />
            â€¢ Reuse Views ÙÙŠ RecyclerView<br />
            â€¢ StringBuilder Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† String concatenation<br />
            <br />
            <strong>3. Ø£Ø¯Ø± Large Objects Ø¨Ø°ÙƒØ§Ø¡:</strong><br />
            â€¢ Bitmaps: downsample Ù„Ø­Ø¬Ù… Ø§Ù„Ø´Ø§Ø´Ø©<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… Glide/Coil (ÙŠØ¯ÙŠØ±ÙˆÙ† Memory)<br />
            â€¢ Database: Pagination<br />
            â€¢ Lists: LazyColumn/LazyRow<br />
            <br />
            <strong>4. Ø±Ø§Ù‚Ø¨ Performance:</strong><br />
            â€¢ Memory Profiler â†’ Heap dumps<br />
            â€¢ LeakCanary ÙÙŠ debug builds<br />
            â€¢ Allocation tracking<br />
            â€¢ Benchmark memory usage<br />
            <br />
            <strong>5. Ø§Ø­ØªØ±Ù… Android Limits:</strong><br />
            â€¢ Ø§Ø¹Ø±Ù heap limit: Runtime.maxMemory()<br />
            â€¢ Ø§Ø³ØªØ¬Ø¨ Ù„Ù€ onTrimMemory()<br />
            â€¢ Ù†Ø¸Ù‘Ù Caches Ø¹Ù†Ø¯ Low memory<br />
            â€¢ Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… android:largeHeap Ø¨Ø¯ÙˆÙ† Ø³Ø¨Ø¨<br />
            <br />
            <strong>6. Test Ø¹Ù„Ù‰ Ø£Ø¬Ù‡Ø²Ø© Ø­Ù‚ÙŠÙ‚ÙŠØ©:</strong><br />
            â€¢ Low-end devices (2 GB RAM)<br />
            â€¢ Ø§Ø®ØªØ¨Ø± Rotation (common leak source)<br />
            â€¢ Ø§Ø®ØªØ¨Ø± Background/Foreground transitions<br />
            â€¢ Stress test Ù…Ø¹ Many operations
          </div>

          <h3>Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø¨ØªØ¯Ø¦ ÙˆØ§Ù„Ù…Ø­ØªØ±Ù:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ù…Ø¨ØªØ¯Ø¦</th>
                <th>Ø§Ù„Ù…Ø­ØªØ±Ù</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Ù„Ø§ ÙŠÙÙ‡Ù… Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Virtual Ùˆ Physical Memory</td>
                <td>ÙŠÙÙ‡Ù… ÙƒÙŠÙ OS ÙŠØ¯ÙŠØ± Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø®Ù„Ù Ø§Ù„ÙƒÙˆØ§Ù„ÙŠØ³</td>
              </tr>
              <tr>
                <td>ÙŠØ¹ØªÙ‚Ø¯ Ø£Ù† Memory Ù„Ø§ Ù…Ø­Ø¯ÙˆØ¯Ø©</td>
                <td>ÙŠØ¹Ø±Ù Per-app limits ÙˆÙŠØ­ØªØ±Ù…Ù‡Ø§</td>
              </tr>
              <tr>
                <td>Ù„Ø§ ÙŠØ­Ø°Ù ReferencesØŒ ÙŠØ³Ø¨Ø¨ Leaks</td>
                <td>ÙŠÙ†Ø¸Ù Resources ÙÙŠ Lifecycle callbacks</td>
              </tr>
              <tr>
                <td>ÙŠØ­Ù…Ù‘Ù„ ÙƒÙ„ Images/Data ÙÙŠ Memory</td>
                <td>ÙŠØ³ØªØ®Ø¯Ù… Pagination, Caching, Lazy loading</td>
              </tr>
              <tr>
                <td>Ù„Ø§ ÙŠØ³ØªØ®Ø¯Ù… Memory Profiler</td>
                <td>ÙŠØ±Ø§Ù‚Ø¨ Memory Ø¨Ø§Ø³ØªÙ…Ø±Ø§Ø±ØŒ ÙŠØ­Ù„Ù„ Leaks</td>
              </tr>
              <tr>
                <td>ÙŠØªØ¬Ø§Ù‡Ù„ onTrimMemory()</td>
                <td>ÙŠØ­Ø±Ø± Caches Ø¹Ù†Ø¯ Low memory</td>
              </tr>
            </tbody>
          </table>

          <hr />

          <h2>Ø£Ø³Ø¦Ù„Ø© Ø´Ø§Ø¦Ø¹Ø© (FAQ) ğŸ’­</h2>

          <h3>Ø³1: Ù„Ù…Ø§Ø°Ø§ ØªØ·Ø¨ÙŠÙ‚ÙŠ ÙŠØ³ØªÙ‡Ù„Ùƒ Memory Ø£ÙƒØ«Ø± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…ØŸ</h3>
          <p>
            <strong>Ø£Ø³Ø¨Ø§Ø¨ Ø´Ø§Ø¦Ø¹Ø©:</strong><br />
            â€¢ Memory Leaks (Activity/Fragment/Bitmap)<br />
            â€¢ Large Bitmaps Ø¨Ø¯ÙˆÙ† downsampling<br />
            â€¢ Caches ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©<br />
            â€¢ Loading ÙƒÙ„ Data ÙÙŠ Memory Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Pagination<br />
            <br />
            <strong>Ø§Ù„Ø­Ù„:</strong> Ø§ÙØªØ­ Memory ProfilerØŒ Ø´ÙˆÙ Heap dumpØŒ Ø§Ø¨Ø­Ø« Ø¹Ù† Leaks
          </p>

          <h3>Ø³2: Ù…Ø§ Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Java Heap Ùˆ Native HeapØŸ</h3>
          <p>
            <strong>Java Heap:</strong><br />
            â€¢ Objects Ø§Ù„Ù…ÙØ¯Ø§Ø±Ø© Ø¨ÙˆØ§Ø³Ø·Ø© GC (String, ArrayList...)<br />
            â€¢ Ù…Ø­Ø¯ÙˆØ¯Ø© (192-512 MB Ù†Ù…ÙˆØ°Ø¬ÙŠØ§Ù‹)<br />
            <br />
            <strong>Native Heap:</strong><br />
            â€¢ C/C++ allocations (malloc/free)<br />
            â€¢ Bitmap pixels, NDK code<br />
            â€¢ Ø£Ù‚Ù„ ØªØ­Ø¯ÙŠØ¯Ø§Ù‹ (ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£ÙƒØ«Ø±)<br />
            <br />
            <strong>â†’ Bitmaps ØªØ°Ù‡Ø¨ Ù„Ù€ Native Heap (Android 8+)</strong>
          </p>

          <h3>Ø³3: Ù‡Ù„ System.gc() ÙŠØ³Ø§Ø¹Ø¯ØŸ</h3>
          <p>
            <strong>Ø¹Ø§Ø¯Ø©Ù‹ Ù„Ø§!</strong><br />
            â€¢ System.gc() = hint ÙÙ‚Ø·ØŒ GC Ù‚Ø¯ ÙŠØªØ¬Ø§Ù‡Ù„Ù‡<br />
            â€¢ Ø¥Ø°Ø§ Ø§Ø³ØªÙØ®Ø¯Ù… â†’ ÙŠØ³Ø¨Ø¨ pause ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹<br />
            â€¢ GC ÙŠØ¹Ø±Ù Ø£ÙØ¶Ù„ Ù…ØªÙ‰ ÙŠØ¹Ù…Ù„<br />
            <br />
            <strong>â†’ Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… System.gc() Ø¥Ù„Ø§ ÙÙŠ Ø­Ø§Ù„Ø§Øª Ø®Ø§ØµØ© Ø¬Ø¯Ø§Ù‹!</strong>
          </p>

          <h3>Ø³4: ÙƒÙŠÙ Ø£Ø¹Ø±Ù Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯ÙŠ Memory LeakØŸ</h3>
          <p>
            <strong>Ø¹Ù„Ø§Ù…Ø§Øª:</strong><br />
            â€¢ Memory usage ÙŠØ²Ø¯Ø§Ø¯ ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹<br />
            â€¢ ØªØ·Ø¨ÙŠÙ‚Ùƒ Ø¨Ø·ÙŠØ¡ Ø¨Ø¹Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø·ÙˆÙŠÙ„<br />
            â€¢ OutOfMemoryError ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©<br />
            <br />
            <strong>Ø§Ù„ÙƒØ´Ù:</strong><br />
            â€¢ Memory Profiler â†’ Force GC â†’ Heap Dump<br />
            â€¢ Ø§Ø¨Ø­Ø« Ø¹Ù†: Activity instances > 1<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… LeakCanary (ÙŠÙƒØ´Ù ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹!)
          </p>

          <h3>Ø³5: Ù…ØªÙ‰ Ø£Ø³ØªØ®Ø¯Ù… WeakReferenceØŸ</h3>
          <p>
            <strong>Ø§Ø³ØªØ®Ø¯Ù… WeakReference Ù„Ù€:</strong><br />
            â€¢ Caches (LRU Cache internally uses WeakReference)<br />
            â€¢ Listeners ØªØ­ØªØ§Ø¬ ØªÙ†Ø¸ÙŠÙ<br />
            â€¢ References Ù„Ù€ Activity/Fragment ÙÙŠ background threads<br />
            <br />
            <strong>Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Ù„Ù€:</strong><br />
            â€¢ Data ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ù‚Ù‰ (ViewModel, Repository)<br />
            â€¢ Short-lived objects (overhead Ø¨Ù„Ø§ ÙØ§Ø¦Ø¯Ø©)
          </p>

          <hr />

          <h2>Ø®Ø§ØªÙ…Ø© ğŸ</h2>

          <blockquote>
            <strong>Memory Management Ù„ÙŠØ³ Ù…Ø¬Ø±Ø¯ ØªÙØ§ØµÙŠÙ„ ØªÙ‚Ù†ÙŠØ©</strong><br />
            <br />
            Ù‡Ùˆ <strong>Ø§Ù„Ø£Ø³Ø§Ø³</strong> Ø§Ù„Ø°ÙŠ ÙŠÙØ¨Ù†Ù‰ Ø¹Ù„ÙŠÙ‡:<br />
            â€¢ Ø§Ù„Ø£Ù…Ø§Ù† (Isolation Ø¨ÙŠÙ† Processes)<br />
            â€¢ Ø§Ù„Ø£Ø¯Ø§Ø¡ (Efficient allocation, minimal GC)<br />
            â€¢ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± (No leaks, no crashes)<br />
            â€¢ ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Smooth, responsive apps)<br />
            <br />
            <strong>Ø¹Ù†Ø¯Ù…Ø§ ØªÙÙ‡Ù… Memory Management:</strong><br />
            âœ“ ØªÙƒØªØ¨ ÙƒÙˆØ¯ memory-efficient<br />
            âœ“ ØªØªØ¬Ù†Ø¨ Leaks Ùˆ OutOfMemoryError<br />
            âœ“ ØªÙÙ‡Ù… Ù„Ù…Ø§Ø°Ø§ ØªØ·Ø¨ÙŠÙ‚Ùƒ Ø¨Ø·ÙŠØ¡<br />
            âœ“ ØªØ­Ø³Ù‘Ù† Performance Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­<br />
            âœ“ ØªØ¨Ù†ÙŠ ØªØ·Ø¨ÙŠÙ‚Ø§Øª ØªØ¹Ù…Ù„ Ø­ØªÙ‰ Ø¹Ù„Ù‰ Ø£Ø¬Ù‡Ø²Ø© Ø¶Ø¹ÙŠÙØ©<br />
            <br />
            <strong>Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³ Ø§Ù„Ù…Ø­ØªØ±Ù ÙŠØ­ØªØ±Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø­Ø¯ÙˆØ¯Ø©ØŒ ÙˆÙŠØ¯ÙŠØ±Ù‡Ø§ Ø¨Ø­ÙƒÙ…Ø©. ğŸ§ </strong>
          </blockquote>

          <div class="info">
            <strong>ğŸ’¡ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©:</strong><br />
            1. Ø§ÙØªØ­ Android Studio Memory Profiler<br />
            2. Ø´ØºÙ‘Ù„ ØªØ·Ø¨ÙŠÙ‚Ùƒ<br />
            3. Ø±Ø§Ù‚Ø¨ Memory usage<br />
            4. Force GC Ø¹Ø¯Ø© Ù…Ø±Ø§Øª<br />
            5. Dump Heap<br />
            6. Ø§Ø¨Ø­Ø« Ø¹Ù†: Activity, Fragment, Bitmap<br />
            7. Ø¥Ø°Ø§ ÙˆØ¬Ø¯Øª > 1 instance â†’ Memory Leak! ğŸ”<br />
            <br />
            <strong>â†’ Memory Profiler = Ø£ÙØ¶Ù„ ØµØ¯ÙŠÙ‚ Ù„Ùƒ! ğŸ“Š</strong>
          </div>

        </div>
      </div>
    </div>
  </div>
</body>
</html>
