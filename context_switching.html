<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <title>Context Switching - Ù„Ù…Ø§Ø°Ø§ Ù‡Ùˆ Ù…ÙƒÙ„Ù ÙˆÙƒÙŠÙ ÙŠØ¤Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¯Ø§Ø¡ØŸ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f7f8fa;
      --card: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --border: #e5e7eb;
      --accent: #2563eb;
      --code-bg: #666666;
      --code-text: #ffffff;
    }

    * {
      box-sizing: border-box;
      font-family: 'Nunito', 'Segoe UI', Tahoma, Arial, sans-serif;
    }

    body {
      margin: 0;
      font-family: 'Nunito', 'Segoe UI', Tahoma, Arial, sans-serif; 
      background: var(--bg);
      color: var(--text);
      line-height: 1.8;
    }

    .page {
      max-width: 980px;
      margin: auto;
      padding: 32px 16px;
    }

    .content {
      background: var(--card);
      border-radius: 12px;
      padding: 32px;
      border: 1px solid var(--border);
    }

    h1, h2, h3, h4 {
      color: #111827;
      margin-top: 32px;
    }

    h1 {
      font-size: 2.1rem;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 8px;
    }

    h2 {
      font-size: 1.6rem;
      border-right: 4px solid var(--accent);
      padding-right: 12px;
    }

    h3 {
      font-size: 1.3rem;
    }

    h4 {
      font-size: 1.1rem;
      color: #374151;
    }

    p {
      margin: 12px 0;
    }

    hr {
      margin: 40px 0;
      border: none;
      height: 1px;
      background: var(--border);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0;
      font-size: 0.95rem;
    }

    table th,
    table td {
      border: 1px solid var(--border);
      padding: 10px;
      text-align: right;
    }

    table th {
      background: #f1f5f9;
      font-weight: 600;
    }

    ul, ol {
      padding-right: 20px;
    }

    blockquote {
      background: #f1f5f9;
      border-right: 4px solid var(--accent);
      padding: 12px 16px;
      margin: 16px 0;
      color: #374151;
    }

    pre {
      background: var(--code-bg);
      color: var(--code-text);
      padding: 16px;
      border-radius: 10px;
      overflow-x: auto;
      margin: 16px 0;
      font-size: 0.9rem;
      direction: ltr;
      text-align: left;
    }

    code {
      font-family: 'Roboto Mono', 'Courier New', monospace;
    }

    p code {
      background: #eef2ff;
      color: #1e40af;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 0.85em;
    }

    section {
      margin-bottom: 32px;
    }

    .warning {
      background: #fef2f2;
      border-right: 4px solid #dc2626;
      padding: 12px 16px;
      margin: 16px 0;
      color: #991b1b;
    }

    .success {
      background: #f0fdf4;
      border-right: 4px solid #16a34a;
      padding: 12px 16px;
      margin: 16px 0;
      color: #166534;
    }

    .info {
      background: #eff6ff;
      border-right: 4px solid #2563eb;
      padding: 12px 16px;
      margin: 16px 0;
      color: #1e40af;
    }

    @media (max-width: 600px) {
      .content {
        padding: 20px;
      }

      h1 {
        font-size: 1.7rem;
      }

      h2 {
        font-size: 1.4rem;
      }
    }
  </style>
</head>

<body>
  <div class="page">
    <div class="content">
      <div class="crossnote markdown-preview">
        <div dir="rtl">
          <h1>Ù…Ø§ Ù‡Ùˆ Context Switching ÙˆÙ„Ù…Ø§Ø°Ø§ Ù‡Ùˆ Ù…ÙƒÙ„ÙØŸ âš¡</h1>

          <h2>Ø§Ù„Ù…Ø­ØªÙˆÙŠØ§Øª</h2>
          <p>
            1 - Ø§Ù„Ù…ÙÙ‡ÙˆÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ: Ù…Ø§ Ù‡Ùˆ Context SwitchingØŸ<br />
            2 - Ø§Ù„ØªØ´Ø¨ÙŠÙ‡ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ: Ø§Ù„Ù…Ø·Ø¨Ø® ÙˆØ§Ù„Ø·Ù‡Ø§Ø©<br />
            3 - Ù…Ø§ Ø§Ù„Ø°ÙŠ ÙŠØ­Ø¯Ø« Ø®Ù„Ø§Ù„ Context SwitchØŸ<br />
            4 - Ù„Ù…Ø§Ø°Ø§ Context Switching Ù…ÙƒÙ„ÙØŸ<br />
            5 - Process Context Switch vs Thread Context Switch<br />
            6 - ØªØ£Ø«ÙŠØ± Context Switching Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¯Ø§Ø¡<br />
            7 - Context Switching ÙÙŠ Android<br />
            8 - ÙƒÙŠÙ ØªÙ‚Ù„Ù„ Ù…Ù† ØªÙƒÙ„ÙØ© Context SwitchingØŸ<br />
            9 - Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ© Ù…Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹<br />
            10 - Ø§Ù„Ù‚ÙŠØ§Ø³ ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„<br />
            11 - Ø§Ù„Ø®Ù„Ø§ØµØ© ÙˆØ§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
          </p>

          <hr />

          <h2>Ø§Ù„Ù…ÙÙ‡ÙˆÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ: Ù…Ø§ Ù‡Ùˆ Context SwitchingØŸ ğŸ¯</h2>

          <h3>Ø§Ù„ØªØ¹Ø±ÙŠÙ Ù…Ù† Ù…Ù†Ø¸ÙˆØ± Ø¹Ù‚Ù„ÙŠ:</h3>

          <blockquote>
            <strong>Context Switching</strong> = Ø¹Ù…Ù„ÙŠØ© Ø¥ÙŠÙ‚Ø§Ù ØªÙ†ÙÙŠØ° Process/Thread ÙˆØªØ´ØºÙŠÙ„ Ø¢Ø®Ø±<br />
            <br />
            ØªØ®ÙŠÙ„ Ø£Ù†Ùƒ ØªÙ‚Ø±Ø£ ÙƒØªØ§Ø¨Ù‹Ø§ØŒ Ø«Ù… ÙŠØ£ØªÙŠ Ø´Ø®Øµ ÙˆÙŠÙ‚Ø§Ø·Ø¹Ùƒ Ù„ØªØ¬ÙŠØ¨ Ø¹Ù„Ù‰ Ø³Ø¤Ø§Ù„ØŒ Ø«Ù… ØªØ¹ÙˆØ¯ Ù„Ù„ÙƒØªØ§Ø¨:<br />
            â€¢ ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ÙØ¸ Ø§Ù„ØµÙØ­Ø© Ø§Ù„ØªÙŠ ÙˆØµÙ„Øª Ø¥Ù„ÙŠÙ‡Ø§ (Save State)<br />
            â€¢ ØªØªØ±Ùƒ Ø§Ù„ÙƒØªØ§Ø¨ ÙˆØªØ¬ÙŠØ¨ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¤Ø§Ù„ (Switch)<br />
            â€¢ ØªØ¹ÙˆØ¯ ÙˆØªØ¨Ø­Ø« Ø¹Ù† Ø§Ù„ØµÙØ­Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ (Restore State)<br />
            <br />
            <strong>â†’ Ù‡Ø°Ø§ Ù‡Ùˆ Context Switching!</strong>
          </blockquote>

          <h3>Ø§Ù„ØªØ¹Ø±ÙŠÙ Ø§Ù„ØªÙ‚Ù†ÙŠ:</h3>

          <div class="info">
            <strong>ğŸ¯ Context Switching:</strong><br />
            Ø¹Ù…Ù„ÙŠØ© Ø­ÙØ¸ Ø­Ø§Ù„Ø© Process/Thread Ø§Ù„Ø­Ø§Ù„ÙŠ (Context) ÙˆØ§Ø³ØªØ¹Ø§Ø¯Ø© Ø­Ø§Ù„Ø© Process/Thread Ø¢Ø®Ø±ØŒ Ø­ØªÙ‰ ÙŠØªÙ…ÙƒÙ† CPU Ù…Ù† Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¨ÙŠÙ†Ù‡Ù….<br />
            <br />
            <strong>Context ÙŠØ´Ù…Ù„:</strong><br />
            â€¢ CPU Registers (PC, SP, General Purpose Registers)<br />
            â€¢ Process/Thread State (Running, Ready, Blocked)<br />
            â€¢ Memory Management Info (Page Tables, TLB)<br />
            â€¢ I/O Status (Open Files, Network Connections)<br />
            â€¢ Priority & Scheduling Info
          </div>

          <h3>Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:</h3>

          <div dir="ltr">
            <pre>Context Switch = Save Current State + Load Next State + Overhead

Time Cost:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Thread Context Switch:   1-5 microseconds     â”‚
â”‚  Process Context Switch:  10-100 microseconds  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Why so expensive?
â€¢ CPU Register Save/Restore
â€¢ Memory Cache Invalidation (Cache Miss)
â€¢ TLB Flush (Translation Lookaside Buffer)
â€¢ Pipeline Flush (Instruction Pipeline)
â€¢ OS Scheduler Overhead</pre>
          </div>

          <hr />

          <h2>Ø§Ù„ØªØ´Ø¨ÙŠÙ‡ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ: Ø§Ù„Ù…Ø·Ø¨Ø® ÙˆØ§Ù„Ø·Ù‡Ø§Ø© ğŸ‘¨â€ğŸ³</h2>

          <h3>ØªØ®ÙŠÙ„ Ù…Ø·Ø¨Ø® Ù…Ø·Ø¹Ù… Ù…Ø²Ø¯Ø­Ù…:</h3>

          <div dir="ltr">
            <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Ø§Ù„Ù…Ø·Ø¨Ø® (CPU)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  ğŸ“ Chef 1 ÙŠØ·Ø¨Ø® Burger:                            â”‚
â”‚     â”œâ”€ ÙŠÙ†Ø¸Ø± ÙÙŠ Ø§Ù„ÙˆØµÙØ© (Read Instruction)           â”‚
â”‚     â”œâ”€ ÙŠÙ…Ø³Ùƒ Ù…Ù‚Ù„Ø§Ø© (Load Register)                  â”‚
â”‚     â”œâ”€ ÙŠØ¶Ø¹ Ø§Ù„Ù„Ø­Ù… (Execute)                         â”‚
â”‚     â””â”€ [ÙŠÙÙ‚Ø§Ø·Ø¹!] ğŸ”” Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯ Ø£ÙƒØ«Ø± Ø£ÙˆÙ„ÙˆÙŠØ©!         â”‚
â”‚                                                     â”‚
â”‚  ğŸ’¾ Context Switch ÙŠØ­Ø¯Ø« Ø§Ù„Ø¢Ù†:                      â”‚
â”‚     1. Chef 1 ÙŠÙˆÙ‚Ù Ø¹Ù…Ù„Ù‡                            â”‚
â”‚     2. ÙŠØ­ÙØ¸ Ø­Ø§Ù„ØªÙ‡:                                 â”‚
â”‚        â””â”€ "ÙƒÙ†Øª Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø·ÙˆØ© 3 ÙÙŠ Ø§Ù„ÙˆØµÙØ©"             â”‚
â”‚        â””â”€ "Ø§Ù„Ù„Ø­Ù… Ø¹Ù„Ù‰ Ø­Ø±Ø§Ø±Ø© 180Â°"                   â”‚
â”‚        â””â”€ "Ø¨Ù‚Ù‰ 5 Ø¯Ù‚Ø§Ø¦Ù‚"                            â”‚
â”‚     3. ÙŠÙ†Ø¸Ù ÙŠØ¯ÙŠÙ‡ ÙˆÙŠØºÙŠØ± Ø§Ù„Ø£Ø¯ÙˆØ§Øª                     â”‚
â”‚     4. ÙŠØ£Ø®Ø° ÙˆØµÙØ© Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯ (Pizza)              â”‚
â”‚     5. ÙŠØªØ°ÙƒØ± Ø£ÙŠÙ† ÙˆØµÙ„ ÙÙŠ Pizza (Restore State)      â”‚
â”‚     6. ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Pizza                        â”‚
â”‚                                                     â”‚
â”‚  â± Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù‡Ø¯ÙˆØ±:                                 â”‚
â”‚     â€¢ Ø­ÙØ¸ Ø­Ø§Ù„Ø© Burger: 2 Ø«Ø§Ù†ÙŠØ©                     â”‚
â”‚     â€¢ ØªÙ†Ø¸ÙŠÙ ÙˆØªØ¨Ø¯ÙŠÙ„: 3 Ø«ÙˆØ§Ù†ÙŠ                        â”‚
â”‚     â€¢ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø­Ø§Ù„Ø© Pizza: 2 Ø«Ø§Ù†ÙŠØ©                  â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”‚
â”‚     Total Overhead: 7 Ø«ÙˆØ§Ù†ÙŠ = Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø·Ø¨Ø® Ø­Ù‚ÙŠÙ‚ÙŠ!  â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <blockquote>
            <strong>ğŸ­ Ø§Ù„Ø¯Ø±Ø³:</strong><br />
            ÙƒÙ„Ù…Ø§ Ø²Ø§Ø¯ Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ â†’ Ø²Ø§Ø¯ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù‡Ø¯ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©ØŒ ÙˆÙ‚Ù„ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ Ù„Ù„Ø¹Ù…Ù„!<br />
            <br />
            ÙÙŠ CPU:<br />
            â€¢ ÙƒÙ„ Context Switch = ÙˆÙ‚Øª Ù…Ù‡Ø¯ÙˆØ± Ø¨Ø¯ÙˆÙ† Ø¥Ù†ØªØ§Ø¬<br />
            â€¢ ÙƒØ«Ø±Ø© Context Switching = ØªØ¨Ø§Ø·Ø¤ Ù…Ù„Ø­ÙˆØ¸ ÙÙŠ Ø§Ù„Ø£Ø¯Ø§Ø¡
          </blockquote>

          <hr />

          <h2>Ù…Ø§ Ø§Ù„Ø°ÙŠ ÙŠØ­Ø¯Ø« Ø®Ù„Ø§Ù„ Context SwitchØŸ âš™ï¸</h2>

          <h3>Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©:</h3>

          <div dir="ltr">
            <pre>Context Switch Sequence (Thread â†’ Thread):

T = 0Î¼s: Thread A ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ CPU
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CPU Executing Thread A                       â”‚
â”‚ â”œâ”€ PC = 0x4000  (Program Counter)            â”‚
â”‚ â”œâ”€ SP = 0x8000  (Stack Pointer)              â”‚
â”‚ â”œâ”€ R1-R15 = active values                    â”‚
â”‚ â””â”€ Cache: filled with Thread A data          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

T = 1Î¼s: Interrupt! (Timer or I/O)
â””â”€â†’ CPU ØªÙˆÙ‚Ù ÙÙˆØ±Ù‹Ø§!

T = 2Î¼s: Save Thread A Context
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OS Kernel Mode                               â”‚
â”‚ â”œâ”€ Save PC to Thread A's PCB                 â”‚
â”‚ â”œâ”€ Save SP to Thread A's PCB                 â”‚
â”‚ â”œâ”€ Save all Registers (R0-R15)               â”‚
â”‚ â”œâ”€ Save FPU State (Floating Point)           â”‚
â”‚ â”œâ”€ Mark Thread A as "Ready" (not Running)    â”‚
â”‚ â””â”€ Update Thread A's statistics              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

T = 3Î¼s: Scheduler Decision
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Which Thread to run next?                    â”‚
â”‚ â”œâ”€ Check Priority                            â”‚
â”‚ â”œâ”€ Check Wait Time                           â”‚
â”‚ â”œâ”€ Check CPU Affinity                        â”‚
â”‚ â””â”€ Decision: Thread B!                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

T = 4Î¼s: Load Thread B Context
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Restore Thread B's state from PCB            â”‚
â”‚ â”œâ”€ Load PC from Thread B's saved state       â”‚
â”‚ â”œâ”€ Load SP from Thread B's saved state       â”‚
â”‚ â”œâ”€ Restore all Registers (R0-R15)            â”‚
â”‚ â”œâ”€ Restore FPU State                         â”‚
â”‚ â”œâ”€ Switch Stack (SP now points to Thread B)  â”‚
â”‚ â””â”€ Mark Thread B as "Running"                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

T = 5Î¼s: Cache & TLB Effects
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¥ Problem: Cache is "cold"                  â”‚
â”‚ â”œâ”€ Cache filled with Thread A's data         â”‚
â”‚ â”œâ”€ Thread B needs different data             â”‚
â”‚ â”œâ”€ Cache Miss â†’ fetch from RAM (100+ cycles) â”‚
â”‚ â””â”€ TLB Miss â†’ page table walk (50+ cycles)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

T = 10Î¼s: Thread B Starts Executing
â””â”€â†’ Actual work resumes!

Total Cost: 10 microseconds of pure overhead!</pre>
          </div>

          <h3>PCB (Process Control Block):</h3>

          <div dir="ltr">
            <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Process Control Block (PCB)           â”‚
â”‚      Ø£Ùˆ Thread Control Block (TCB)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚  Process ID (PID):          12345           â”‚
â”‚  Process State:             Running         â”‚
â”‚  Program Counter (PC):      0x00401000      â”‚
â”‚  Stack Pointer (SP):        0x7FFF8000      â”‚
â”‚                                             â”‚
â”‚  CPU Registers:                             â”‚
â”‚  â”œâ”€ R0:  0x00000001                         â”‚
â”‚  â”œâ”€ R1:  0x00000042                         â”‚
â”‚  â”œâ”€ R2:  0xDEADBEEF                         â”‚
â”‚  â””â”€ ... (R3-R15)                            â”‚
â”‚                                             â”‚
â”‚  Memory Management:                         â”‚
â”‚  â”œâ”€ Page Table Base:  0x12340000            â”‚
â”‚  â”œâ”€ Code Segment:     0x00400000-0x0040FFFFâ”‚
â”‚  â”œâ”€ Data Segment:     0x00600000-0x0060FFFFâ”‚
â”‚  â””â”€ Stack Segment:    0x7FFF0000-0x7FFFFFFFâ”‚
â”‚                                             â”‚
â”‚  I/O Status:                                â”‚
â”‚  â”œâ”€ Open Files:       [fd0, fd3, fd7]       â”‚
â”‚  â”œâ”€ Network Sockets:  [socket5]             â”‚
â”‚  â””â”€ Pending I/O:      None                  â”‚
â”‚                                             â”‚
â”‚  Scheduling Info:                           â”‚
â”‚  â”œâ”€ Priority:         High (120)            â”‚
â”‚  â”œâ”€ CPU Time Used:    450ms                 â”‚
â”‚  â”œâ”€ Time Quantum:     10ms                  â”‚
â”‚  â””â”€ Wait Time:        5ms                   â”‚
â”‚                                             â”‚
â”‚  Parent PID:          1000                  â”‚
â”‚  Child PIDs:          [12346, 12347]        â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <hr />

          <h2>Ù„Ù…Ø§Ø°Ø§ Context Switching Ù…ÙƒÙ„ÙØŸ ğŸ’°</h2>

          <h3>Ø§Ù„ØªÙƒØ§Ù„ÙŠÙ Ø§Ù„Ø®Ù…Ø³ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:</h3>

          <h4>1. CPU Register Save/Restore (Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©):</h4>

          <div dir="ltr">
            <pre>Modern CPU has ~32-64 Registers to save:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ General Purpose: R0-R15   (16 regs)    â”‚
â”‚ Floating Point:  F0-F31   (32 regs)    â”‚
â”‚ Vector/SIMD:     V0-V31   (32 regs)    â”‚
â”‚ Special:         PC, SP, LR, etc       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Cost per register: ~1 CPU cycle
Total: 80-100 CPU cycles just for save/restore

On 2 GHz CPU:
â€¢ 100 cycles â‰ˆ 50 nanoseconds
â€¢ Seems cheap? Not really when done millions of times!</pre>
          </div>

          <h4>2. Cache Pollution (Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø®ÙÙŠØ© Ø§Ù„Ø£ÙƒØ¨Ø±):</h4>

          <div dir="ltr">
            <pre>Cache Hierarchy:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L1 Cache:  32 KB, 4 cycles   (~2 ns)          â”‚
â”‚  L2 Cache: 256 KB, 12 cycles  (~6 ns)          â”‚
â”‚  L3 Cache:   8 MB, 40 cycles  (~20 ns)         â”‚
â”‚  RAM:       8 GB, 200+ cycles (~100 ns)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Before Context Switch:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ L1 Cache: [Thread A data]  âœ“      â”‚ â† Hot, fast access
â”‚ L2 Cache: [Thread A data]  âœ“      â”‚
â”‚ L3 Cache: [Thread A data]  âœ“      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

After Context Switch to Thread B:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ L1 Cache: [Thread A data]  âŒ      â”‚ â† Thread B needs different data
â”‚           â†’ CACHE MISS! ğŸ’¥         â”‚ â† Must fetch from RAM (100+ ns)
â”‚ L2 Cache: [Thread A data]  âŒ      â”‚
â”‚ L3 Cache: [Thread A data]  âŒ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Result:
â€¢ Next 1000+ memory accesses = SLOW (cache miss)
â€¢ Performance drops by 10-100x until cache warms up!

This is why Context Switch feels "expensive"!</pre>
          </div>

          <h4>3. TLB Flush (Memory Translation):</h4>

          <div dir="ltr">
            <pre>TLB (Translation Lookaside Buffer):
â€¢ Cache Ù„Ù€ Virtual â†’ Physical address translation
â€¢ Size: 64-512 entries
â€¢ Access: 1 cycle (fast!)

During Process Context Switch:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Process A's TLB:                           â”‚
â”‚ Virtual Address â†’ Physical Address         â”‚
â”‚ 0x00400000      â†’ 0x12340000   âœ“          â”‚
â”‚ 0x00401000      â†’ 0x12341000   âœ“          â”‚
â”‚ ... (64 entries cached)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Switch to Process B:
â””â”€â†’ TLB FLUSH! (must invalidate all entries)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Process B's TLB:                           â”‚
â”‚ [Empty - must rebuild]  âŒ                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Cost:
â€¢ Every memory access needs page table walk (50+ cycles)
â€¢ Until TLB refills (gradual)
â€¢ Hundreds of microseconds of slowdown!

Note: Thread Context Switch (same process) = NO TLB flush âœ“</pre>
          </div>

          <h4>4. Pipeline Flush (Instruction Execution):</h4>

          <div dir="ltr">
            <pre>Modern CPU Pipeline (simplified):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 1: Fetch    â†’ [Instruction 1]             â”‚
â”‚ Stage 2: Decode   â†’ [Instruction 2]             â”‚
â”‚ Stage 3: Execute  â†’ [Instruction 3]             â”‚
â”‚ Stage 4: Memory   â†’ [Instruction 4]             â”‚
â”‚ Stage 5: Write    â†’ [Instruction 5]             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
All stages work in parallel = 5x throughput!

During Context Switch:
â””â”€â†’ Pipeline FLUSH! (throw away all in-flight instructions)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 1: [Empty]  âŒ                            â”‚
â”‚ Stage 2: [Empty]  âŒ                            â”‚
â”‚ Stage 3: [Empty]  âŒ                            â”‚
â”‚ Stage 4: [Empty]  âŒ                            â”‚
â”‚ Stage 5: [Empty]  âŒ                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Cost: 5-20 cycles wasted (depending on pipeline depth)
On deep pipelines (20+ stages): 20+ cycles = 10+ ns</pre>
          </div>

          <h4>5. OS Scheduler Overhead:</h4>

          <div dir="ltr">
            <pre>Scheduler Work during Context Switch:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Save current thread state  (50 ns)  â”‚
â”‚ 2. Update statistics          (20 ns)  â”‚
â”‚ 3. Scan ready queue           (100 ns) â”‚
â”‚ 4. Calculate priorities       (50 ns)  â”‚
â”‚ 5. Pick next thread           (30 ns)  â”‚
â”‚ 6. Load next thread state     (50 ns)  â”‚
â”‚ 7. Update bookkeeping         (20 ns)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Total: ~320 nanoseconds

For 100 threads competing:
â€¢ Scan time increases â†’ O(n)
â€¢ More complexity â†’ more overhead</pre>
          </div>

          <h3>Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ù…ÙƒÙˆÙ†</th>
                <th>Ø§Ù„ØªÙƒÙ„ÙØ© (Ù†Ø§Ù†ÙˆØ«Ø§Ù†ÙŠØ©)</th>
                <th>Ø§Ù„Ù†Ø³Ø¨Ø©</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Register Save/Restore</strong></td>
                <td>50 ns</td>
                <td>5%</td>
              </tr>
              <tr>
                <td><strong>Scheduler Overhead</strong></td>
                <td>300 ns</td>
                <td>30%</td>
              </tr>
              <tr>
                <td><strong>Pipeline Flush</strong></td>
                <td>10 ns</td>
                <td>1%</td>
              </tr>
              <tr>
                <td><strong>TLB Flush (Process only)</strong></td>
                <td>100 ns</td>
                <td>10%</td>
              </tr>
              <tr>
                <td><strong>Cache Miss Penalty</strong></td>
                <td>500+ ns</td>
                <td>50%+</td>
              </tr>
            </tbody>
          </table>

          <div class="warning">
            <strong>âš ï¸ Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø­Ø±Ø¬Ø©:</strong><br />
            <strong>Cache Miss</strong> Ù‡Ùˆ Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø£ÙƒØ¨Ø±!<br />
            â€¢ Register Save = 50 ns<br />
            â€¢ Cache Miss = 500+ ns (10x Ø£ØºÙ„Ù‰!)<br />
            <br />
            <strong>â†’ Context Switching Ù„ÙŠØ³ Ù…ÙƒÙ„ÙÙ‹Ø§ Ø¨Ø³Ø¨Ø¨ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù†ÙØ³Ù‡ØŒ Ø¨Ù„ Ø¨Ø³Ø¨Ø¨ Cache Pollution!</strong>
          </div>

          <hr />

          <h2>Process Context Switch vs Thread Context Switch ğŸ”„</h2>

          <h3>Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ø¬Ø§Ù†Ø¨</th>
                <th>Thread Context Switch</th>
                <th>Process Context Switch</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Ø§Ù„ÙˆÙ‚Øª</strong></td>
                <td>1-5 Âµs</td>
                <td>10-100 Âµs (10-20x Ø£Ø¨Ø·Ø£)</td>
              </tr>
              <tr>
                <td><strong>Register Save/Restore</strong></td>
                <td>Ù†Ø¹Ù… âœ“</td>
                <td>Ù†Ø¹Ù… âœ“</td>
              </tr>
              <tr>
                <td><strong>Stack Switch</strong></td>
                <td>Ù†Ø¹Ù… âœ“</td>
                <td>Ù†Ø¹Ù… âœ“</td>
              </tr>
              <tr>
                <td><strong>TLB Flush</strong></td>
                <td>Ù„Ø§ âŒ (Ù†ÙØ³ Address Space)</td>
                <td>Ù†Ø¹Ù… âœ“ (Ù…ÙƒÙ„Ù Ø¬Ø¯Ù‹Ø§!)</td>
              </tr>
              <tr>
                <td><strong>Cache Pollution</strong></td>
                <td>Ù…ØªÙˆØ³Ø· (Ù†ÙØ³ Heap)</td>
                <td>Ø¹Ø§Ù„ÙŠ (Heap Ù…Ø®ØªÙ„Ù ØªÙ…Ø§Ù…Ù‹Ø§)</td>
              </tr>
              <tr>
                <td><strong>Memory Protection Switch</strong></td>
                <td>Ù„Ø§ âŒ</td>
                <td>Ù†Ø¹Ù… âœ“ (Page Table Switch)</td>
              </tr>
            </tbody>
          </table>

          <h3>Ù„Ù…Ø§Ø°Ø§ Thread Ø£Ø³Ø±Ø¹ Ù…Ù† ProcessØŸ</h3>

          <div dir="ltr">
            <pre>Thread Context Switch (Same Process):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Before: Thread A running                     â”‚
â”‚ â”œâ”€ PC, SP, Registers: Thread A               â”‚
â”‚ â”œâ”€ Page Table: Process X                     â”‚ â† Ù„Ø§ ÙŠØªØºÙŠØ±
â”‚ â”œâ”€ TLB: Process X mappings                   â”‚ â† Ù„Ø§ ÙŠØªØºÙŠØ±
â”‚ â””â”€ Cache: Process X data                     â”‚ â† Ø¨Ø¹Ø¶Ù‡ Ù…Ø´ØªØ±Ùƒ
â”‚                                              â”‚
â”‚ After: Thread B running (same Process X)     â”‚
â”‚ â”œâ”€ PC, SP, Registers: Thread B               â”‚ â† ÙŠØªØºÙŠØ±
â”‚ â”œâ”€ Page Table: Process X                     â”‚ â† Ù†ÙØ³Ù‡! âœ“
â”‚ â”œâ”€ TLB: Process X mappings                   â”‚ â† Ù†ÙØ³Ù‡! âœ“
â”‚ â””â”€ Cache: Process X data                     â”‚ â† Ø¨Ø¹Ø¶Ù‡ ÙŠÙØ¹Ø§Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ âœ“
â”‚                                              â”‚
â”‚ Savings:                                     â”‚
â”‚ â€¢ No TLB flush                               â”‚
â”‚ â€¢ Shared Heap in Cache                       â”‚
â”‚ â€¢ Same Page Table                            â”‚
â”‚ â†’ 5-10x faster!                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Process Context Switch:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Before: Process A running                    â”‚
â”‚ â”œâ”€ PC, SP, Registers: Process A              â”‚
â”‚ â”œâ”€ Page Table: Process A                     â”‚
â”‚ â”œâ”€ TLB: Process A mappings                   â”‚
â”‚ â””â”€ Cache: Process A data                     â”‚
â”‚                                              â”‚
â”‚ After: Process B running                     â”‚
â”‚ â”œâ”€ PC, SP, Registers: Process B              â”‚ â† ÙŠØªØºÙŠØ±
â”‚ â”œâ”€ Page Table: Process B                     â”‚ â† ÙŠØªØºÙŠØ±! ğŸ’°
â”‚ â”œâ”€ TLB: Process B mappings (FLUSHED!)        â”‚ â† ÙŠØªØºÙŠØ±! ğŸ’°ğŸ’°
â”‚ â””â”€ Cache: Process B data (COLD!)             â”‚ â† ÙŠØªØºÙŠØ±! ğŸ’°ğŸ’°ğŸ’°
â”‚                                              â”‚
â”‚ Costs:                                       â”‚
â”‚ â€¢ TLB flush + refill: 100+ ns                â”‚
â”‚ â€¢ Cache pollution: 500+ ns                   â”‚
â”‚ â€¢ Page table switch: 50 ns                   â”‚
â”‚ â†’ 10-20x slower than Thread!                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <hr />

          <h2>ØªØ£Ø«ÙŠØ± Context Switching Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¯Ø§Ø¡ ğŸ“Š</h2>

          <h3>Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ 1: ØªØ·Ø¨ÙŠÙ‚ Ø¨Ø³ÙŠØ· (Low Context Switching):</h3>

          <div dir="ltr">
            <pre>Scenario: Single-threaded app doing computation

Timeline (1 second):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Thread A: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]  â”‚ â† 99% CPU time
â”‚ Context Switches: â–¼    â–¼    â–¼    â–¼    â–¼       â”‚ â† 1% overhead
â”‚                  (OS checks every 10ms)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Statistics:
â€¢ Context Switches: 100/second (every 10ms)
â€¢ Time per switch: 5 Âµs
â€¢ Total overhead: 100 * 5Âµs = 500Âµs = 0.05%
â€¢ Useful work: 99.95%

Result: âœ… Context switching is negligible!</pre>
          </div>

          <h3>Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ 2: ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ù‚Ø¯ (High Context Switching):</h3>

          <div dir="ltr">
            <pre>Scenario: 100 threads competing for 4 CPU cores

Timeline (1 second):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CPU1: [â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼]   â”‚
â”‚ CPU2: [â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼]   â”‚
â”‚ CPU3: [â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼]   â”‚
â”‚ CPU4: [â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼â–ˆâ–¼]   â”‚
â”‚       â–ˆ = 100Âµs work  â–¼ = 5Âµs context switch   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Statistics:
â€¢ Context Switches: 100,000/second per core
â€¢ Time per switch: 5 Âµs
â€¢ Total overhead: 4 cores * 100,000 * 5Âµs = 2 seconds!
â€¢ But we only have 4 seconds total (4 cores * 1 second)
â€¢ Overhead: 50%!

Result: âŒ Half the CPU time is wasted on context switching!</pre>
          </div>

          <h3>Ù‚Ø§Ù†ÙˆÙ† Ø§Ù„Ø¹ÙˆØ§Ø¦Ø¯ Ø§Ù„Ù…ØªÙ†Ø§Ù‚ØµØ©:</h3>

          <div dir="ltr">
            <pre>Threads vs Performance:

Throughput
    â”‚
100%â”‚     â–ˆâ–ˆâ–ˆâ–ˆ
    â”‚    â–ˆâ–ˆ  â–ˆâ–ˆ
 80%â”‚   â–ˆâ–ˆ    â–ˆâ–ˆ
    â”‚  â–ˆâ–ˆ      â–ˆâ–ˆ
 60%â”‚ â–ˆâ–ˆ        â–ˆâ–ˆâ–ˆ
    â”‚â–ˆâ–ˆ          â–ˆâ–ˆâ–ˆâ–ˆ
 40%â”‚â–ˆ             â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â”‚                     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
 20%â”‚
    â”‚
  0%â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Number of Threads
      1  4   8   16  32  64  128  256

Optimal Zone: ~CPU cores * 2
After that: Diminishing returns due to context switching!

Real Data (4-core CPU):
â€¢ 4 threads:   100% efficiency âœ“
â€¢ 8 threads:   95% efficiency  âœ“
â€¢ 16 threads:  85% efficiency  âš ï¸
â€¢ 32 threads:  70% efficiency  âš ï¸
â€¢ 64 threads:  50% efficiency  âŒ
â€¢ 128 threads: 30% efficiency  âŒâŒ</pre>
          </div>

          <div class="warning">
            <strong>âš ï¸ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©:</strong><br />
            <strong>Number of Threads â‰ˆ Number of CPU Cores * 2</strong><br />
            <br />
            â€¢ Ø£Ù‚Ù„ Ù…Ù† Ø°Ù„Ùƒ â†’ CPU ØºÙŠØ± Ù…Ø³ØªØºÙ„ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„<br />
            â€¢ Ø£ÙƒØ«Ø± Ù…Ù† Ø°Ù„Ùƒ â†’ Context Switching ÙŠØ£ÙƒÙ„ Ø§Ù„Ø£Ø¯Ø§Ø¡<br />
            <br />
            ÙÙŠ Android (Ø¹Ø§Ø¯Ø© 8 cores):<br />
            <strong>â†’ Optimal Thread Pool Size = 8-16 threads</strong>
          </div>

          <hr />

          <h2>Context Switching ÙÙŠ Android ğŸ“±</h2>

          <h3>Android Scheduler Strategy:</h3>

          <div dir="ltr">
            <pre>Android uses CFS (Completely Fair Scheduler):

Priority Levels:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ -20 to -16:  Foreground (UI Thread, Active App) â”‚ â† High Priority
â”‚ -15 to -10:  Visible Apps                       â”‚
â”‚  -9 to -1 :  Background Services                â”‚
â”‚   0 to 10 :  Background (Cached Apps)           â”‚ â† Low Priority
â”‚  11 to 19 :  Idle (Very Low Priority)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Typical Android App Threads:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Main Thread (UI):           Priority -10        â”‚ â† ÙŠØ­ØµÙ„ Ø¹Ù„Ù‰ CPU Ø£ÙˆÙ„Ø§Ù‹
â”‚ RenderThread:               Priority -4         â”‚
â”‚ Binder Threads (8x):        Priority 0          â”‚
â”‚ Background Worker Threads:  Priority 10         â”‚
â”‚ GC Thread:                  Priority 5          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Time Quantum per thread: 5-10ms
â†’ Ø¨Ø¹Ø¯Ù‡Ø§ Context Switch ØªÙ„Ù‚Ø§Ø¦ÙŠ (Ø­ØªÙ‰ Ù„Ùˆ Thread Ù„Ù… ÙŠÙ†ØªÙ‡ÙŠ)</pre>
          </div>

          <h3>Main Thread Protection ÙÙŠ Android:</h3>

          <div dir="ltr">
            <pre>Android aggressively protects Main Thread:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Main Thread Time Slice: 10ms                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                â”‚
â”‚  If Main Thread used < 10ms:                   â”‚
â”‚  â””â”€â†’ Voluntarily yields (goes to sleep)        â”‚
â”‚      â””â”€â†’ Context Switch to next thread         â”‚
â”‚          â””â”€â†’ Cost: 5 Âµs                        â”‚
â”‚                                                â”‚
â”‚  If Main Thread blocked (waiting for I/O):     â”‚
â”‚  â””â”€â†’ Immediate Context Switch                  â”‚
â”‚      â””â”€â†’ Don't waste CPU time!                 â”‚
â”‚                                                â”‚
â”‚  If Main Thread running for > 16ms:            â”‚
â”‚  â””â”€â†’ âš ï¸ Frame Drop! (Jank)                     â”‚
â”‚      â””â”€â†’ User sees lag                         â”‚
â”‚                                                â”‚
â”‚  If Main Thread running for > 5 seconds:       â”‚
â”‚  â””â”€â†’ ğŸ’€ ANR Dialog!                            â”‚
â”‚      â””â”€â†’ App Not Responding                    â”‚
â”‚                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Why 16ms? â†’ 60 FPS = 16.6ms per frame
â€¢ Main Thread must finish work in 16ms
â€¢ Otherwise: Frame drop â†’ Jank â†’ Bad UX</pre>
          </div>

          <h3>Ù…Ø«Ø§Ù„: Ù…Ø§Ø°Ø§ ÙŠØ­Ø¯Ø« Ø¹Ù†Ø¯ Scrolling ÙÙŠ RecyclerViewØŸ</h3>

          <div dir="ltr">
            <pre>User Scrolls RecyclerView (60 FPS):

Frame 1 (0-16ms):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Main Thread:                              â”‚
â”‚ â”œâ”€ 0-1ms:   Handle Touch Event            â”‚
â”‚ â”œâ”€ 1-8ms:   Measure & Layout Views        â”‚
â”‚ â”œâ”€ 8-12ms:  Bind ViewHolders              â”‚
â”‚ â”œâ”€ 12-14ms: Draw to Canvas                â”‚
â”‚ â””â”€ 14-16ms: Submit to RenderThread        â”‚ âœ“
â”‚                                           â”‚
â”‚ RenderThread (parallel):                  â”‚
â”‚ â””â”€ 0-16ms: Rasterize previous frame       â”‚
â”‚                                           â”‚
â”‚ Background Threads (parallel):            â”‚
â”‚ â”œâ”€ Load images from disk/network         â”‚
â”‚ â””â”€ Decode bitmaps                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Frame 2 (16-32ms): Same pattern...

Context Switches per Frame:
â€¢ Main Thread yields: 1-2 times (voluntary)
â€¢ Background Threads preempted: 5-10 times
â€¢ Total: ~10-15 Context Switches per Frame

At 60 FPS:
â€¢ 60 frames * 15 switches = 900 switches/second
â€¢ 900 * 5Âµs = 4.5ms overhead
â€¢ On 4 cores = ~1-2% overhead âœ“ Acceptable!

But if you create 100 background threads:
â€¢ 60 frames * 100 switches = 6,000 switches/second
â€¢ 6,000 * 5Âµs = 30ms overhead
â€¢ Frames start dropping â†’ Jank! âŒ</pre>
          </div>

          <h3>Binder IPC Context Switching:</h3>

          <div dir="ltr">
            <pre>IPC Call example: App â†’ System Service

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ App Process (PID 12345)                        â”‚
â”‚ â”œâ”€ Main Thread calls:                          â”‚
â”‚ â”‚  locationManager.getLastKnownLocation()      â”‚
â”‚ â”‚                                              â”‚
â”‚ â”‚  â†“ Binder IPC (crosses process boundary)    â”‚
â”‚ â”‚                                              â”‚
â”‚ â””â”€â†’ Context Switch! (5-50 Âµs)                  â”‚
â”‚     â”œâ”€ Save App's state                        â”‚
â”‚     â”œâ”€ Switch to Kernel                        â”‚
â”‚     â”œâ”€ Marshall data                           â”‚
â”‚     â””â”€ Context Switch to System Server         â”‚
â”‚                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ System Server Process (PID 1000)               â”‚
â”‚ â”œâ”€ Binder Thread receives request              â”‚
â”‚ â”œâ”€ Executes: getLastKnownLocation()            â”‚
â”‚ â”‚  â””â”€ Access GPS, check permissions, etc.     â”‚
â”‚ â”‚                                              â”‚
â”‚ â”‚  â†“ Return result via Binder                 â”‚
â”‚ â”‚                                              â”‚
â”‚ â””â”€â†’ Context Switch back! (5-50 Âµs)             â”‚
â”‚     â”œâ”€ Marshall result                         â”‚
â”‚     â”œâ”€ Switch to Kernel                        â”‚
â”‚     â”œâ”€ Switch back to App Process              â”‚
â”‚     â””â”€ Restore App's state                     â”‚
â”‚                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total Cost:
â€¢ 2 Context Switches (Process level)
â€¢ 2 Data Marshalling operations
â€¢ Kernel overhead
â†’ 50-500 microseconds total

This is why:
â€¢ IPC calls are "expensive"
â€¢ Should be minimized
â€¢ Should not be called on Main Thread for heavy operations</pre>
          </div>

          <hr />

          <h2>ÙƒÙŠÙ ØªÙ‚Ù„Ù„ Ù…Ù† ØªÙƒÙ„ÙØ© Context SwitchingØŸ ğŸ› </h2>

          <h3>Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© 1: ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø¯Ø¯ Threads</h3>

          <div dir="ltr">
            <pre>// âŒ Ø³ÙŠØ¦: Ø¥Ù†Ø´Ø§Ø¡ Thread Ù„ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ©
fun loadImages(urls: List<String>) {
    urls.forEach { url ->
        Thread {
            val image = downloadImage(url)
            saveToCache(image)
        }.start()
    }
    // 100 URLs = 100 Threads = Disaster! ğŸ’¥
    // Context switching overhead >> actual work
}


// âœ… Ø¬ÙŠØ¯: Ø§Ø³ØªØ®Ø¯Ø§Ù… Thread Pool
fun loadImages(urls: List<String>) {
    val executor = Executors.newFixedThreadPool(4)  // ÙÙ‚Ø· 4 threads
    
    urls.forEach { url ->
        executor.execute {
            val image = downloadImage(url)
            saveToCache(image)
        }
    }
    // 100 URLs, 4 threads = efficient!
    // Threads reused, minimal context switching
    
    executor.shutdown()
}


// âœ… Ø£ÙØ¶Ù„: Coroutines Ù…Ø¹ Dispatcher Ù…Ø­Ø¯ÙˆØ¯
suspend fun loadImages(urls: List<String>) {
    val dispatcher = Dispatchers.IO.limitedParallelism(4)
    
    urls.map { url ->
        async(dispatcher) {
            val image = downloadImage(url)
            saveToCache(image)
        }
    }.awaitAll()
    
    // Coroutines: Ø®ÙÙŠÙØ©ØŒ efficient scheduling
    // Context switching minimal
}</pre>
          </div>

          <h3>Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© 2: Batch Processing</h3>

          <div dir="ltr">
            <pre>// âŒ Ø³ÙŠØ¦: Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¹Ù†ØµØ± ÙˆØ§Ø­Ø¯ ÙÙŠ ÙƒÙ„ Ù…Ø±Ø©
fun processItems(items: List<Item>) {
    items.forEach { item ->
        thread {
            process(item)  // Thread Ø¬Ø¯ÙŠØ¯ Ù„ÙƒÙ„ item
            // Context switch overhead!
        }
    }
}


// âœ… Ø¬ÙŠØ¯: Ù…Ø¹Ø§Ù„Ø¬Ø© Batch
fun processItems(items: List<Item>) {
    val batchSize = 100
    val executor = Executors.newFixedThreadPool(4)
    
    items.chunked(batchSize).forEach { batch ->
        executor.execute {
            batch.forEach { item ->
                process(item)  // Ù…Ø¹Ø§Ù„Ø¬Ø© 100 items ÙÙŠ thread ÙˆØ§Ø­Ø¯
            }
        }
    }
    
    executor.shutdown()
}

// Result:
// Before: 1000 items = 1000 threads = 1000+ context switches
// After:  1000 items = 10 batches = 10 threads = ~10 context switches
// â†’ 100x reduction in context switching!</pre>
          </div>

          <h3>Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© 3: CPU Affinity</h3>

          <div dir="ltr">
            <pre>// CPU Affinity: ØªØ«Ø¨ÙŠØª Thread Ø¹Ù„Ù‰ CPU Ù…Ø­Ø¯Ø¯
// Ù„ØªÙ‚Ù„ÙŠÙ„ Cache misses

// ÙÙŠ Linux/Android (low-level):
fun setCpuAffinity(threadId: Int, cpuCore: Int) {
    // Native call to sched_setaffinity()
    // Pins thread to specific CPU core
}

// ÙØ§Ø¦Ø¯Ø©:
// Thread A Ø¹Ù„Ù‰ CPU 0 Ø¯Ø§Ø¦Ù…Ù‹Ø§
// â†’ Cache CPU 0 ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Thread A
// â†’ Ø¹Ù†Ø¯ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù€ Thread AØŒ Cache warm! âœ“

// Android Framework Ù„Ø§ ÙŠØ¹Ø±Ø¶ Ù‡Ø°Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©
// Ù„ÙƒÙ† Scheduler ÙŠØ­Ø§ÙˆÙ„ ØªØ­Ù‚ÙŠÙ‚Ù‡ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ (Cache affinity)</pre>
          </div>

          <h3>Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© 4: Lock-Free Programming</h3>

          <div dir="ltr">
            <pre>// âŒ Ø³ÙŠØ¦: Lock ÙŠØ³Ø¨Ø¨ Context Switching
class Counter {
    private var count = 0
    private val lock = Any()
    
    fun increment() {
        synchronized(lock) {  // Thread blocks if lock held
            count++           // â†’ Context switch to another thread
        }
    }
}

// Thread A ÙŠÙ…Ø³Ùƒ lock
// Thread B ÙŠØ­Ø§ÙˆÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ â†’ blocked!
// â†’ OS ÙŠØ¹Ù…Ù„ Context Switch Ù„Ù€ Thread C
// â†’ Wasted context switch!


// âœ… Ø¬ÙŠØ¯: Atomic (lock-free)
class Counter {
    private val count = AtomicInteger(0)
    
    fun increment() {
        count.incrementAndGet()  // Hardware atomic instruction
        // No lock, no blocking, no context switch!
    }
}

// Threads ØªØªÙ†Ø§ÙØ³ Ø¹Ù„Ù‰ CPU instruction level
// Ù„Ø§ ÙŠÙˆØ¬Ø¯ OS context switching
// â†’ 10-100x faster!</pre>
          </div>

          <h3>Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© 5: Reduce IPC Calls</h3>

          <div dir="ltr">
            <pre>// âŒ Ø³ÙŠØ¦: IPC Ù„ÙƒÙ„ item
fun saveSettings(settings: Map<String, String>) {
    settings.forEach { (key, value) ->
        // ÙƒÙ„ set() = IPC call = 2 context switches!
        sharedPreferences.edit().putString(key, value).apply()
    }
}
// 100 settings = 200 context switches! ğŸ’°


// âœ… Ø¬ÙŠØ¯: Batch IPC
fun saveSettings(settings: Map<String, String>) {
    sharedPreferences.edit().apply {
        settings.forEach { (key, value) ->
            putString(key, value)
        }
    }.apply()  // ÙˆØ§Ø­Ø¯Ø© IPC call ÙÙ‚Ø·!
}
// 100 settings = 2 context switches âœ“


// Real example: ContentProvider batch operations
// âŒ Ø³ÙŠØ¦:
contacts.forEach { contact ->
    contentResolver.insert(ContactsContract.CONTENT_URI, contact)
    // Each insert = IPC call
}

// âœ… Ø¬ÙŠØ¯:
val operations = contacts.map { contact ->
    ContentProviderOperation.newInsert(ContactsContract.CONTENT_URI)
        .withValues(contact)
        .build()
}
contentResolver.applyBatch(ContactsContract.AUTHORITY, operations)
// Batch = ÙˆØ§Ø­Ø¯Ø© IPC call!</pre>
          </div>

          <hr />

          <h2>Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ© Ù…Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ ğŸ’¡</h2>

          <h3>Ù…Ø«Ø§Ù„ 1: Image Loading Library (Glide/Coil)</h3>

          <div dir="ltr">
            <pre>// ÙƒÙŠÙ Glide ÙŠØªØ¬Ù†Ø¨ Context Switching:

class ImageLoader {
    // Thread Pool Ù…Ø­Ø¯ÙˆØ¯ (4 threads ÙÙ‚Ø·)
    private val diskExecutor = Executors.newFixedThreadPool(4)
    private val networkExecutor = Executors.newFixedThreadPool(2)
    
    // LRU Cache Ù„ØªØ¬Ù†Ø¨ re-loading
    private val memoryCache = LruCache<String, Bitmap>(cacheSize)
    
    fun load(url: String, callback: (Bitmap) -> Unit) {
        // 1. Check memory cache (Main Thread - fast!)
        memoryCache.get(url)?.let {
            callback(it)
            return  // No context switch needed!
        }
        
        // 2. Check disk cache (Background Thread)
        diskExecutor.execute {
            val cachedBitmap = loadFromDisk(url)
            if (cachedBitmap != null) {
                memoryCache.put(url, cachedBitmap)
                runOnMainThread { callback(cachedBitmap) }
                return@execute
            }
            
            // 3. Download from network (Network Thread)
            networkExecutor.execute {
                val bitmap = downloadImage(url)
                saveToDisk(url, bitmap)
                memoryCache.put(url, bitmap)
                runOnMainThread { callback(bitmap) }
            }
        }
    }
}

// Why efficient?
âœ“ Limited thread pools (4+2 threads, not 1000!)
âœ“ Memory cache avoids thread switches (hits ~80%)
âœ“ Disk cache reduces network threads (hits ~15%)
âœ“ Only 5% actually download (minimal context switching)

Result:
â€¢ 100 images to load
â€¢ 80 from memory (no thread, 0 context switches)
â€¢ 15 from disk (4 threads reused, ~30 context switches)
â€¢ 5 from network (2 threads reused, ~10 context switches)
â†’ Total: ~40 context switches vs 200+ without optimization!</pre>
          </div>

          <h3>Ù…Ø«Ø§Ù„ 2: Database Access (Room)</h3>

          <div dir="ltr">
            <pre>// âŒ Ø³ÙŠØ¦: Thread Ù„ÙƒÙ„ query
class UserRepository {
    fun getUser(id: Int): User {
        return thread {
            database.userDao().getUser(id)
        }.get()
    }
}

// 100 sequential queries:
// = 100 threads created/destroyed
// = 200+ context switches
// = slow!


// âœ… Ø¬ÙŠØ¯: Single background thread with queue
class UserRepository {
    private val executor = Executors.newSingleThreadExecutor()
    
    fun getUser(id: Int, callback: (User) -> Unit) {
        executor.execute {
            val user = database.userDao().getUser(id)
            mainHandler.post { callback(user) }
        }
    }
}

// 100 queries:
// = 1 thread (reused)
// = ~2 context switches (once to background, once back)
// = fast! âœ“


// âœ… Ø£ÙØ¶Ù„: Room + Coroutines (official recommendation)
@Dao
interface UserDao {
    @Query("SELECT * FROM users WHERE id = :id")
    suspend fun getUser(id: Int): User  // suspend = coroutine-friendly
}

class UserRepository(private val dao: UserDao) {
    suspend fun getUser(id: Int): User {
        return withContext(Dispatchers.IO) {
            dao.getUser(id)
        }
    }
}

// ÙÙŠ ViewModel:
viewModelScope.launch {
    val users = (1..100).map { id ->
        async { repository.getUser(id) }
    }.awaitAll()
}

// Coroutines:
// â€¢ Light weight (no full thread per query)
// â€¢ Dispatchers.IO uses optimized thread pool
// â€¢ Minimal context switching
// â†’ Best performance! âœ“âœ“</pre>
          </div>

          <h3>Ù…Ø«Ø§Ù„ 3: Networking (Retrofit + OkHttp)</h3>

          <div dir="ltr">
            <pre>// OkHttp Connection Pool strategy:

class OkHttpClient {
    private val connectionPool = ConnectionPool(
        maxIdleConnections = 5,  // Ø¥Ø¨Ù‚Ø§Ø¡ 5 connections Ù…ÙØªÙˆØ­Ø©
        keepAliveDuration = 5,   // Ù„Ù…Ø¯Ø© 5 Ø¯Ù‚Ø§Ø¦Ù‚
        TimeUnit.MINUTES
    )
    
    private val dispatcher = Dispatcher().apply {
        maxRequests = 64              // Maximum concurrent requests
        maxRequestsPerHost = 5        // Per host limit
    }
}

// Why?
1. Connection Reuse:
   â€¢ Opening TCP connection = expensive (3-way handshake)
   â€¢ SSL/TLS handshake = very expensive (multiple round trips)
   â€¢ Reusing connection = no handshake = fast!
   
2. Limited Parallelism:
   â€¢ 64 concurrent requests maximum
   â€¢ Uses shared thread pool (not 1 thread per request!)
   â€¢ Reduces context switching

// Example: 100 API calls

// âŒ Without connection pool:
â€¢ 100 TCP connections opened/closed
â€¢ 100 SSL handshakes
â€¢ 100+ threads
â€¢ 1000+ context switches
â€¢ Time: 10+ seconds

// âœ… With connection pool:
â€¢ 5 TCP connections (reused)
â€¢ 5 SSL handshakes
â€¢ ~10 threads (thread pool)
â€¢ ~100 context switches
â€¢ Time: 2-3 seconds
â†’ 5x faster! âœ“</pre>
          </div>

          <h3>Ù…Ø«Ø§Ù„ 4: RecyclerView Prefetching</h3>

          <div dir="ltr">
            <pre>// RecyclerView intelligent prefetching:

class RecyclerView {
    private val prefetchRegistry = GapWorker.LayoutPrefetchRegistryImpl()
    
    fun onScroll() {
        // 1. Detect scroll direction & velocity
        val velocity = computeVelocity()
        
        // 2. Predict which items will be visible soon
        val upcomingItems = predictUpcomingItems(velocity)
        
        // 3. Prefetch on IDLE time (avoid context switch during frame)
        if (isIdle && upcomingItems.isNotEmpty()) {
            prefetchRegistry.addPosition(upcomingItems.first())
            
            // Prefetch runs on Main Thread during IDLE!
            // â†’ No context switch needed
            // â†’ Cache warm when item actually needed
        }
    }
}

// Why smart?
Traditional approach:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User scrolls                            â”‚
â”‚ â†’ New item visible                      â”‚
â”‚ â†’ Context switch to background          â”‚
â”‚ â†’ Load data                             â”‚
â”‚ â†’ Context switch to main                â”‚
â”‚ â†’ Bind & display                        â”‚
â”‚ â†’ User sees delay (Jank!)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RecyclerView prefetch:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User scrolling (current frame)          â”‚
â”‚ â†’ Predict next items                    â”‚
â”‚ â†’ Prefetch on IDLE (same thread!)       â”‚
â”‚ â†’ Cache warm                            â”‚
â”‚ User scrolls more (next frame)          â”‚
â”‚ â†’ Item already ready!                   â”‚
â”‚ â†’ Bind instantly (no delay)             â”‚
â”‚ â†’ Smooth 60 FPS âœ“                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Result: Reduced context switching + better UX!</pre>
          </div>

          <hr />

          <h2>Ø§Ù„Ù‚ÙŠØ§Ø³ ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„ ğŸ“Š</h2>

          <h3>ÙƒÙŠÙ ØªÙ‚ÙŠØ³ Context Switching ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ÙƒØŸ</h3>

          <h4>1. Android Studio Profiler:</h4>

          <div dir="ltr">
            <pre>Steps:
1. Open Android Studio
2. Run â†’ Profile 'app'
3. CPU Profiler â†’ Record
4. Threads tab â†’ Check:
   â”œâ”€ Number of threads (should be < 20)
   â”œâ”€ Thread activity (green = running, gray = sleeping)
   â””â”€ Context switches (rapid color changes = bad!)

What to look for:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… Good:                               â”‚
â”‚ Main Thread:    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â”‚ â† Mostly green
â”‚ Worker Thread:  â–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆ   â”‚ â† Bursts of activity
â”‚ Idle Thread:    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚ â† Mostly gray
â”‚                                        â”‚
â”‚ âŒ Bad:                                â”‚
â”‚ Main Thread:    â–ˆâ–“â–’â–‘â–ˆâ–“â–’â–‘â–ˆâ–“â–’â–‘â–ˆâ–“â–’â–‘â–ˆâ–“â–’    â”‚ â† Too many switches
â”‚ Worker Threads: â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“    â”‚ â† Thrashing!
â”‚ (20+ threads competing)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <h4>2. Systrace (Advanced):</h4>

          <div dir="ltr">
            <pre>// Capture systrace:
$ python systrace.py -t 10 sched freq idle -o trace.html

// Analyze:
â€¢ Look for "sched_switch" events
â€¢ High frequency = excessive context switching
â€¢ Color-coded timeline shows which thread running on which CPU

Example findings:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CPU 0: [Thread A][Thread B][Thread A]...  â”‚
â”‚        â†‘ switch   â†‘ switch  â†‘ switch      â”‚
â”‚                                            â”‚
â”‚ Good:  ~100 switches/second                â”‚
â”‚ Bad:   ~10,000 switches/second             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <h4>3. Code Instrumentation:</h4>

          <div dir="ltr">
            <pre>// Ù‚ÙŠØ§Ø³ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯:

class ContextSwitchMonitor {
    private var lastThreadId = 0L
    private var switchCount = 0
    
    fun checkSwitch() {
        val currentThreadId = Thread.currentThread().id
        if (currentThreadId != lastThreadId) {
            switchCount++
            Log.d("ContextSwitch", "Switch #$switchCount: " +
                  "Thread $lastThreadId â†’ Thread $currentThreadId")
        }
        lastThreadId = currentThreadId
    }
}

// Ø§Ø³ØªØ®Ø¯Ø§Ù…:
val monitor = ContextSwitchMonitor()

fun doWork() {
    monitor.checkSwitch()  // Ù‚Ø¨Ù„ Ø§Ù„Ø¹Ù…Ù„
    // ... actual work
    monitor.checkSwitch()  // Ø¨Ø¹Ø¯ Ø§Ù„Ø¹Ù…Ù„
}

// Results:
// High switch count = optimization needed!</pre>
          </div>

          <h3>Benchmarking Context Switching:</h3>

          <div dir="ltr">
            <pre>// Micro-benchmark: Ù‚ÙŠØ§Ø³ ØªÙƒÙ„ÙØ© Context Switch

fun benchmarkContextSwitch() {
    val iterations = 10000
    
    // Test 1: Thread creation + switch
    val startThreads = System.nanoTime()
    repeat(iterations) {
        val thread = Thread { /* minimal work */ }
        thread.start()
        thread.join()
    }
    val timeThreads = (System.nanoTime() - startThreads) / iterations
    println("Thread creation + switch: ${timeThreads / 1000} Âµs")
    
    // Test 2: Thread Pool (reuse)
    val executor = Executors.newFixedThreadPool(4)
    val startPool = System.nanoTime()
    val latch = CountDownLatch(iterations)
    repeat(iterations) {
        executor.execute {
            // minimal work
            latch.countDown()
        }
    }
    latch.await()
    val timePool = (System.nanoTime() - startPool) / iterations
    println("Thread pool: ${timePool / 1000} Âµs")
    
    executor.shutdown()
    
    // Test 3: Coroutines
    val startCoroutines = System.nanoTime()
    runBlocking {
        repeat(iterations) {
            launch(Dispatchers.Default) {
                // minimal work
            }
        }
    }
    val timeCoroutines = (System.nanoTime() - startCoroutines) / iterations
    println("Coroutines: ${timeCoroutines / 1000} Âµs")
}

// Typical Results (Ø¹Ù„Ù‰ Pixel 6):
// Thread creation + switch: 150 Âµs
// Thread pool:              8 Âµs   (20x faster!)
// Coroutines:              2 Âµs   (75x faster!)

// Conclusion: Thread Pool Ùˆ Coroutines Ø£ÙØ¶Ù„ Ø¨ÙƒØ«ÙŠØ±!</pre>
          </div>

          <hr />

          <h2>Ø§Ù„Ø®Ù„Ø§ØµØ© ÙˆØ§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ğŸ“</h2>

          <h3>Ù…Ù„Ø®Øµ Ø§Ù„ØªÙƒØ§Ù„ÙŠÙ:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ù†ÙˆØ¹</th>
                <th>Ø§Ù„ÙˆÙ‚Øª</th>
                <th>Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Thread Context Switch</strong></td>
                <td>1-5 Âµs</td>
                <td>Cache pollution, Register save/restore</td>
              </tr>
              <tr>
                <td><strong>Process Context Switch</strong></td>
                <td>10-100 Âµs</td>
                <td>TLB flush, Cache flush, Memory protection switch</td>
              </tr>
              <tr>
                <td><strong>IPC (Binder)</strong></td>
                <td>50-500 Âµs</td>
                <td>2x Process context switches + Marshalling</td>
              </tr>
              <tr>
                <td><strong>System Call</strong></td>
                <td>0.1-1 Âµs</td>
                <td>User â†’ Kernel mode switch</td>
              </tr>
            </tbody>
          </table>

          <h3>Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©:</h3>

          <div dir="ltr">
            <pre>âœ“ Context Switching = Ø­ÙØ¸ ÙˆØ§Ø³ØªØ¹Ø§Ø¯Ø© Ø­Ø§Ù„Ø© Thread/Process
âœ“ Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø£ÙƒØ¨Ø± = Cache Miss (Ù„ÙŠØ³ Register Save!)
âœ“ Thread Switch Ø£Ø±Ø®Øµ 10-20x Ù…Ù† Process Switch
âœ“ Optimal Thread Count â‰ˆ CPU Cores * 2
âœ“ ÙƒØ«Ø±Ø© Threads = Context Switching Overhead
âœ“ Thread Pool Ø£ÙØ¶Ù„ Ù…Ù† Ø¥Ù†Ø´Ø§Ø¡ Threads Ø¬Ø¯ÙŠØ¯Ø©
âœ“ Coroutines Ø£Ø®Ù Ù…Ù† Threads
âœ“ Batch Operations ØªÙ‚Ù„Ù„ IPC Context Switches
âœ“ Lock-Free Programming ÙŠØªØ¬Ù†Ø¨ Context Switching
âœ“ Ù‚ÙØ³ Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ø³ÙŠÙ† (Profiler, Systrace)</pre>
          </div>

          <h3>Best Practices ÙÙŠ Android:</h3>

          <div class="success">
            <strong>âœ… Ø§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:</strong><br />
            <br />
            <strong>1. Ø­Ø¯Ø¯ Ø¹Ø¯Ø¯ Threads:</strong><br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… <code>Executors.newFixedThreadPool(cores * 2)</code><br />
            â€¢ Ø£Ùˆ <code>Dispatchers.IO.limitedParallelism(n)</code><br />
            â€¢ Ù„Ø§ ØªÙ†Ø´Ø¦ 100+ Thread!<br />
            <br />
            <strong>2. Ø£Ø¹Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù… Threads:</strong><br />
            â€¢ Thread Pool Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Thread Ø¬Ø¯ÙŠØ¯ Ù„ÙƒÙ„ task<br />
            â€¢ Coroutines ØªØ¯ÙŠØ± Thread Pool ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§<br />
            <br />
            <strong>3. Ù‚Ù„Ù„ IPC Calls:</strong><br />
            â€¢ Batch operations Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ù…ÙƒØ§Ù†<br />
            â€¢ Cache Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„ØªØ¬Ù†Ø¨ re-calling<br />
            <br />
            <strong>4. Ø§Ø³ØªØ®Ø¯Ù… Lock-Free Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ù…ÙƒØ§Ù†:</strong><br />
            â€¢ <code>AtomicInteger/AtomicReference</code> Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† <code>synchronized</code><br />
            â€¢ <code>ConcurrentHashMap</code> Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† <code>synchronized HashMap</code><br />
            <br />
            <strong>5. Main Thread Protection:</strong><br />
            â€¢ Ù„Ø§ ØªØ¹Ø·Ù„ Main Thread (> 16ms = Jank)<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… <code>Dispatchers.Main</code> Ù„Ù„Ù€ UI ÙÙ‚Ø·<br />
            â€¢ <code>Dispatchers.IO</code> Ù„Ù„Ù€ I/O operations<br />
            <br />
            <strong>6. Profiling Ù…Ù†ØªØ¸Ù…:</strong><br />
            â€¢ Ø±Ø§Ù‚Ø¨ Thread count ÙÙŠ Android Profiler<br />
            â€¢ Ø§Ø¨Ø­Ø« Ø¹Ù† Thread thrashing<br />
            â€¢ Ø­Ù„Ù„ Systrace Ù„Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©
          </div>

          <h3>Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø¨ØªØ¯Ø¦ ÙˆØ§Ù„Ù…Ø­ØªØ±Ù:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ù…Ø¨ØªØ¯Ø¦</th>
                <th>Ø§Ù„Ù…Ø­ØªØ±Ù</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>ÙŠÙ†Ø´Ø¦ Thread Ù„ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ©</td>
                <td>ÙŠØ³ØªØ®Ø¯Ù… Thread Pool Ø£Ùˆ Coroutines</td>
              </tr>
              <tr>
                <td>Ù„Ø§ ÙŠØ¹Ø±Ù Ø¹Ø¯Ø¯ Threads ÙÙŠ ØªØ·Ø¨ÙŠÙ‚Ù‡</td>
                <td>ÙŠØ­Ø¯Ø¯ Ø¹Ø¯Ø¯ Threads Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ CPU cores</td>
              </tr>
              <tr>
                <td>ÙŠØ¹ØªÙ‚Ø¯ Ø£Ù† Threads Ù…Ø¬Ø§Ù†ÙŠØ©</td>
                <td>ÙŠÙÙ‡Ù… ØªÙƒÙ„ÙØ© Context Switching</td>
              </tr>
              <tr>
                <td>ÙŠÙ†Ø´Ø¦ 100 Thread Ù„Ù„Ø³Ø±Ø¹Ø©</td>
                <td>ÙŠØ¹Ø±Ù Ø£Ù† 100 Thread = Ø£Ø¨Ø·Ø£ Ù…Ù† 10 Threads!</td>
              </tr>
              <tr>
                <td>Ù„Ø§ ÙŠØ³ØªØ®Ø¯Ù… Profiler</td>
                <td>ÙŠÙ‚ÙŠØ³ Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆÙŠØ­Ù„Ù„ Context Switches</td>
              </tr>
              <tr>
                <td>ÙŠØ³ØªØ®Ø¯Ù… synchronized ÙƒØ«ÙŠØ±Ù‹Ø§</td>
                <td>ÙŠØ³ØªØ®Ø¯Ù… Lock-Free structures Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ù…ÙƒØ§Ù†</td>
              </tr>
            </tbody>
          </table>

          <hr />

          <h2>Ø£Ø³Ø¦Ù„Ø© Ø´Ø§Ø¦Ø¹Ø© (FAQ) ğŸ’­</h2>

          <h3>Ø³1: Ù‡Ù„ Coroutines ØªØªØ¬Ù†Ø¨ Context Switching ØªÙ…Ø§Ù…Ù‹Ø§ØŸ</h3>
          <p>
            <strong>Ù„Ø§.</strong> Coroutines ØªØ¹Ù…Ù„ ÙÙˆÙ‚ ThreadsØŒ Ù„ÙƒÙ†Ù‡Ø§:<br />
            â€¢ ØªÙ‚Ù„Ù„ Ø¹Ø¯Ø¯ Threads Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© (dispatcher ÙŠÙØ¯ÙŠØ± thread pool)<br />
            â€¢ Suspending Ø£Ø±Ø®Øµ Ù…Ù† Blocking (Ù„Ø§ ÙŠØ¹Ø·Ù„ Thread)<br />
            â€¢ Structured concurrency ØªØªØ¬Ù†Ø¨ Thread leaks<br />
            <br />
            <strong>â†’ Context switching Ù„Ø§ ÙŠØ²Ø§Ù„ ÙŠØ­Ø¯Ø«ØŒ Ù„ÙƒÙ† Ø¨ØªÙƒØ±Ø§Ø± Ø£Ù‚Ù„.</strong>
          </p>

          <h3>Ø³2: Ù„Ù…Ø§Ø°Ø§ ØªØ·Ø¨ÙŠÙ‚ÙŠ Ø¨Ø·ÙŠØ¡ Ø±ØºÙ… Ø£Ù† CPU Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ù…Ù†Ø®ÙØ¶ØŸ</h3>
          <p>
            Ø§Ø­ØªÙ…Ø§Ù„ ÙƒØ¨ÙŠØ±: <strong>Context Switching Overhead!</strong><br />
            â€¢ CPU ÙŠÙ‚Ø¶ÙŠ ÙˆÙ‚Øª ÙÙŠ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¨ÙŠÙ† ThreadsØŒ Ù„ÙŠØ³ ÙÙŠ Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„ÙØ¹Ù„ÙŠ<br />
            â€¢ Ø§ÙØªØ­ Profiler â†’ Threads â†’ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¹Ø¯Ø¯ Threads > 50 â†’ Ù…Ø´ÙƒÙ„Ø©!<br />
            <br />
            <strong>â†’ Ù‚Ù„Ù„ Ø¹Ø¯Ø¯ ThreadsØŒ Ù„Ø§ ØªØ²ÙŠØ¯Ù‡Ø§!</strong>
          </p>

          <h3>Ø³3: Ù…Ø§ Ù‡Ùˆ Thread ThrashingØŸ</h3>
          <p>
            Ø­Ø§Ù„Ø© Ø­ÙŠØ« OS ÙŠÙ‚Ø¶ÙŠ Ù…Ø¹Ø¸Ù… ÙˆÙ‚ØªÙ‡ ÙÙŠ Context Switching Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„ÙØ¹Ù„ÙŠ.<br />
            <strong>Ø£Ø¹Ø±Ø§Ø¶:</strong><br />
            â€¢ CPU Ù…Ø´ØºÙˆÙ„ 100% Ù„ÙƒÙ† Ø§Ù„Ø¥Ù†ØªØ§Ø¬ÙŠØ© Ù‚Ù„ÙŠÙ„Ø©<br />
            â€¢ ØªØ·Ø¨ÙŠÙ‚ Ø¨Ø·ÙŠØ¡ Ø¬Ø¯Ù‹Ø§<br />
            â€¢ Threads ÙƒØ«ÙŠØ±Ø© (50+) ØªØªÙ†Ø§ÙØ³<br />
            <br />
            <strong>Ø§Ù„Ø­Ù„:</strong> Ù‚Ù„Ù„ Ø¹Ø¯Ø¯ Threads Ø¥Ù„Ù‰ ~CPU cores * 2
          </p>

          <h3>Ø³4: Ù…ØªÙ‰ ÙŠÙƒÙˆÙ† Context Switching Ù…Ù‚Ø¨ÙˆÙ„ØŸ</h3>
          <p>
            <strong>Ù…Ù‚Ø¨ÙˆÙ„:</strong><br />
            â€¢ Ø¹Ø¯Ø¯ Ù‚Ù„ÙŠÙ„ Ù…Ù† Context Switches (< 1000/second)<br />
            â€¢ Threads ØªÙ†ØªØ¸Ø± I/O (Blocking operations)<br />
            â€¢ Interactive UI (Main Thread yields voluntarily)<br />
            <br />
            <strong>ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„:</strong><br />
            â€¢ Threads ÙƒØ«ÙŠØ±Ø© ØªØªÙ†Ø§ÙØ³ Ø¹Ù„Ù‰ CPU (CPU-bound work)<br />
            â€¢ Context Switching > 10% Ù…Ù† CPU time<br />
            â€¢ Jank ÙÙŠ UI (frame drops)
          </p>

          <h3>Ø³5: ÙƒÙŠÙ Ø£Ø¹Ø±Ù Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ù…Ø«Ù„ Ù„Ù€ ThreadsØŸ</h3>
          <p>
            <strong>Ù‚Ø§Ø¹Ø¯Ø© Ø¹Ø§Ù…Ø©:</strong><br />
            â€¢ <strong>CPU-bound work:</strong> Threads = CPU cores<br />
            â€¢ <strong>I/O-bound work:</strong> Threads = CPU cores * 2<br />
            â€¢ <strong>Mixed workload:</strong> Threads = CPU cores * 1.5<br />
            <br />
            ÙÙŠ Android (8 cores Ù†Ù…ÙˆØ°Ø¬ÙŠ):<br />
            <strong>â†’ Optimal Thread Pool = 8-16 threads</strong><br />
            <br />
            <strong>Ù„ÙƒÙ†:</strong> Ù‚ÙØ³ ÙˆØ§Ø®ØªØ¨Ø±! ÙƒÙ„ ØªØ·Ø¨ÙŠÙ‚ Ù…Ø®ØªÙ„Ù.
          </p>

          <hr />

          <h2>Ø®Ø§ØªÙ…Ø© ğŸ</h2>

          <blockquote>
            <strong>Context Switching Ù„ÙŠØ³ Ø§Ù„Ø¹Ø¯Ùˆ</strong><br />
            <br />
            Ù‡Ùˆ Ø¶Ø±ÙˆØ±Ø© Ù„Ù†Ø¸Ø§Ù… Multi-tasking.<br />
            Ù„ÙƒÙ† <strong>Ø§Ù„Ø¥ÙØ±Ø§Ø·</strong> ÙÙŠ Context Switching Ù‡Ùˆ Ø§Ù„Ø¹Ø¯Ùˆ!<br />
            <br />
            <strong>Ø§Ù„ÙÙ‡Ù… Ø§Ù„ØµØ­ÙŠØ­:</strong><br />
            â€¢ Context Switching = overhead Ù„Ø§ Ù…ÙØ± Ù…Ù†Ù‡<br />
            â€¢ Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© = Cache Miss (Ù„ÙŠØ³ Register Save)<br />
            â€¢ Thread Pool > Ø¥Ù†Ø´Ø§Ø¡ Threads Ø¬Ø¯ÙŠØ¯Ø©<br />
            â€¢ Coroutines > Threads Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ©<br />
            â€¢ Ù‚ÙŠØ§Ø³ Ø§Ù„Ø£Ø¯Ø§Ø¡ > Ø§Ù„Ø¸Ù†ÙˆÙ†<br />
            <br />
            <strong>Ø¹Ù†Ø¯Ù…Ø§ ØªÙÙ‡Ù… Context Switching:</strong><br />
            âœ“ ØªÙƒØªØ¨ ÙƒÙˆØ¯ Ø£Ø³Ø±Ø¹ (Ø£Ù‚Ù„ threadsØŒ Ø£Ù‚Ù„ overhead)<br />
            âœ“ ØªØªØ¬Ù†Ø¨ Thread thrashing<br />
            âœ“ ØªÙÙ‡Ù… Ù„Ù…Ø§Ø°Ø§ ØªØ·Ø¨ÙŠÙ‚Ùƒ Ø¨Ø·ÙŠØ¡<br />
            âœ“ ØªØªØ®Ø° Ù‚Ø±Ø§Ø±Ø§Øª ØªØµÙ…ÙŠÙ… ØµØ­ÙŠØ­Ø©<br />
            <br />
            <strong>Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³ Ø§Ù„Ù…Ø­ØªØ±Ù ÙŠÙÙ‡Ù… Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø®ÙÙŠØ© Ù„Ù„ØªØ¨Ø¯ÙŠÙ„ØŒ ÙˆÙŠÙØ­Ø³Ù‘Ù† Ø¨Ø­ÙƒÙ…Ø©. âš¡</strong>
          </blockquote>

          <div class="info">
            <strong>ğŸ’¡ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©:</strong><br />
            1. Ø§ÙØªØ­ Android Studio Profiler<br />
            2. Ø§Ø°Ù‡Ø¨ Ù„Ù€ CPU â†’ Threads<br />
            3. Ø¹ÙØ¯ Ø¹Ø¯Ø¯ Threads Ø§Ù„Ù†Ø´Ø·Ø©<br />
            4. Ø¥Ø°Ø§ ÙƒØ§Ù† > 20 â†’ Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ­Ø³ÙŠÙ†!<br />
            5. Ø§Ø³ØªØ®Ø¯Ù… Thread Pool Ø£Ùˆ Coroutines<br />
            6. Ù‚ÙØ³ Ø§Ù„ÙØ±Ù‚ Ù‚Ø¨Ù„ ÙˆØ¨Ø¹Ø¯<br />
            <br />
            <strong>â†’ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØªÙƒØ´Ù Ø§Ù„Ø­Ù‚ÙŠÙ‚Ø©! ğŸ“Š</strong>
          </div>

        </div>
      </div>
    </div>
  </div>
</body>
</html>
