<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <title>Android Lifecycle & Context - Ø¯ÙˆØ±Ø© Ø§Ù„Ø­ÙŠØ§Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f7f8fa;
      --card: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --border: #e5e7eb;
      --accent: #2563eb;
      --code-bg: #666666;
      --code-text: #ffffff;
    }

    * {
      box-sizing: border-box;
      font-family: 'Nunito', 'Segoe UI', Tahoma, Arial, sans-serif;
    }

    body {
      margin: 0;
      font-family: 'Nunito', 'Segoe UI', Tahoma, Arial, sans-serif; 
      background: var(--bg);
      color: var(--text);
      line-height: 1.8;
    }

    .page {
      max-width: 980px;
      margin: auto;
      padding: 32px 16px;
    }

    .content {
      background: var(--card);
      border-radius: 12px;
      padding: 32px;
      border: 1px solid var(--border);
    }

    h1, h2, h3, h4 {
      color: #111827;
      margin-top: 32px;
    }

    h1 {
      font-size: 2.1rem;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 8px;
    }

    h2 {
      font-size: 1.6rem;
      border-right: 4px solid var(--accent);
      padding-right: 12px;
    }

    h3 {
      font-size: 1.3rem;
    }

    h4 {
      font-size: 1.1rem;
      color: #374151;
    }

    p {
      margin: 12px 0;
    }

    hr {
      margin: 40px 0;
      border: none;
      height: 1px;
      background: var(--border);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0;
      font-size: 0.95rem;
    }

    table th,
    table td {
      border: 1px solid var(--border);
      padding: 10px;
      text-align: right;
    }

    table th {
      background: #f1f5f9;
      font-weight: 600;
    }

    ul, ol {
      padding-right: 20px;
    }

    blockquote {
      background: #f1f5f9;
      border-right: 4px solid var(--accent);
      padding: 12px 16px;
      margin: 16px 0;
      color: #374151;
    }

    pre {
      background: var(--code-bg);
      color: var(--code-text);
      padding: 16px;
      border-radius: 10px;
      overflow-x: auto;
      margin: 16px 0;
      font-size: 0.9rem;
      direction: ltr;
      text-align: left;
    }

    code {
      font-family: 'Roboto Mono', 'Courier New', monospace;
    }

    p code {
      background: #eef2ff;
      color: #1e40af;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 0.85em;
    }

    section {
      margin-bottom: 32px;
    }

    .warning {
      background: #fef2f2;
      border-right: 4px solid #dc2626;
      padding: 12px 16px;
      margin: 16px 0;
      color: #991b1b;
    }

    .success {
      background: #f0fdf4;
      border-right: 4px solid #16a34a;
      padding: 12px 16px;
      margin: 16px 0;
      color: #166534;
    }

    .info {
      background: #eff6ff;
      border-right: 4px solid #2563eb;
      padding: 12px 16px;
      margin: 16px 0;
      color: #1e40af;
    }

    @media (max-width: 600px) {
      .content {
        padding: 20px;
      }

      h1 {
        font-size: 1.7rem;
      }

      h2 {
        font-size: 1.4rem;
      }
    }
  </style>
</head>

<body>
  <div class="page">
    <div class="content">
      <div class="crossnote markdown-preview">
        <div dir="rtl">
          <h1>Android Lifecycle & Context Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ ğŸ”„</h1>

          <h2>Ø§Ù„Ù…Ø­ØªÙˆÙŠØ§Øª</h2>
          <p>
            1 - Ø§Ù„Ù€ Lifecycle Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ (Ù„ÙŠØ³ Ø§Ù„Ù…Ø®Ø·Ø· Ø§Ù„Ø¨Ø³ÙŠØ·!)<br />
            2 - Ø§Ù„ØªØ´Ø¨ÙŠÙ‡ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ: Ø§Ù„Ù…Ø³Ø±Ø­ ÙˆØ§Ù„Ù…Ù…Ø«Ù„ÙŠÙ†<br />
            3 - Activity Lifecycle Ø¨Ø§Ù„ØªÙØµÙŠÙ„<br />
            4 - Fragment Lifecycle Ø§Ù„Ù…Ø¹Ù‚Ø¯<br />
            5 - Process Lifecycle (Ø§Ù„Ø£Ù‡Ù…!)<br />
            6 - Ù…Ø§ Ù‡Ùˆ ContextØŸ<br />
            7 - Application Context vs Activity Context<br />
            8 - Ù…ØªÙ‰ ØªØ³ØªØ®Ø¯Ù… Ø£ÙŠ ContextØŸ<br />
            9 - Context Leaks: Ø§Ù„ÙƒØ§Ø¨ÙˆØ³!<br />
            10 - ViewModel ÙˆØ¹Ù„Ø§Ù‚ØªÙ‡ Ø¨Ù€ Lifecycle<br />
            11 - Lifecycle-Aware Components<br />
            12 - Configuration Changes<br />
            13 - Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ© Ù…Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹<br />
            14 - Ø§Ù„Ø®Ù„Ø§ØµØ© ÙˆØ§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
          </p>

          <hr />

          <h2>Ø§Ù„Ù€ Lifecycle Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ (Ù„ÙŠØ³ Ø§Ù„Ù…Ø®Ø·Ø· Ø§Ù„Ø¨Ø³ÙŠØ·!) ğŸ­</h2>

          <h3>Ø§Ù„Ù…Ø®Ø·Ø· Ø§Ù„Ø°ÙŠ ÙŠØ¹Ù„Ù…ÙˆÙ†Ùƒ Ø¥ÙŠØ§Ù‡:</h3>

          <div dir="ltr">
            <pre>Simple Lifecycle (Ù…Ù† Ø§Ù„Ù…Ù‚Ø§Ù„Ø§Øª):

onCreate() â†’ onStart() â†’ onResume() â†’ Running
                              â†“
                          onPause()
                              â†“
                          onStop()
                              â†“
                         onDestroy()

"Ø¨Ø³ÙŠØ·ØŒ ØµØ­ØŸ" ğŸ¤”</pre>
          </div>

          <h3>Ø§Ù„Ù€ Lifecycle Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ (ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹):</h3>

          <div dir="ltr">
            <pre>Real Lifecycle (Ù…Ø§ ÙŠØ­Ø¯Ø« ÙØ¹Ù„Ø§Ù‹):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ App Launch (Cold Start):                        â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 1. Zygote forks Process (~100-200ms)        â”‚ â”‚
â”‚ â”‚ 2. Application.onCreate() âš¡ CRITICAL!      â”‚ â”‚
â”‚ â”‚ 3. ActivityThread.main() starts             â”‚ â”‚
â”‚ â”‚ 4. Inflation begins (XML â†’ Objects)         â”‚ â”‚
â”‚ â”‚ 5. Activity.onCreate() â† You are here       â”‚ â”‚
â”‚ â”‚ 6. Activity.onStart()                       â”‚ â”‚
â”‚ â”‚ 7. Activity.onResume()                      â”‚ â”‚
â”‚ â”‚ 8. View.onAttachedToWindow()                â”‚ â”‚
â”‚ â”‚ 9. View.onMeasure() (multiple times!)       â”‚ â”‚
â”‚ â”‚ 10. View.onLayout() (multiple times!)       â”‚ â”‚
â”‚ â”‚ 11. View.onDraw() â† First frame             â”‚ â”‚
â”‚ â”‚ 12. Choreographer schedules next frame      â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ Total time: 500ms - 2000ms (Visible to user!)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User presses Home:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. onPause() â† Input events stop               â”‚
â”‚ 2. ActivityManagerService notified             â”‚
â”‚ 3. Window animation starts                     â”‚
â”‚ 4. onStop() â† Activity not visible             â”‚
â”‚ 5. Process state: Background (OOM Adj = 400)   â”‚
â”‚ 6. onSaveInstanceState() â† MAY BE CALLED       â”‚
â”‚ 7. Waiting... (might be killed anytime!)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

System kills Process (Low Memory):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. SIGKILL received                             â”‚
â”‚ 2. Process dies instantly (< 100ms)             â”‚
â”‚ 3. onDestroy() NOT CALLED! â˜ ï¸                   â”‚
â”‚ 4. Memory reclaimed                             â”‚
â”‚ 5. Process removed from memory                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User returns to App (Warm/Cold Start):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ IF Process alive:                               â”‚
â”‚ â””â”€â†’ onRestart() â†’ onStart() â†’ onResume()       â”‚
â”‚     (Fast! ~100ms)                              â”‚
â”‚                                                 â”‚
â”‚ IF Process killed:                              â”‚
â”‚ â””â”€â†’ Full recreation (~500-2000ms)              â”‚
â”‚     1. New Process                              â”‚
â”‚     2. Application.onCreate()                   â”‚
â”‚     3. Activity.onCreate(savedInstanceState)    â”‚
â”‚        â†‘ Restore state here!                    â”‚
â”‚     4. onStart() â†’ onResume()                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <blockquote>
            <strong>ğŸ¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø­Ø±Ø¬Ø©:</strong><br />
            <br />
            <strong>1. Application.onCreate() ÙŠÙØ³ØªØ¯Ø¹Ù‰ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·</strong><br />
            â€¢ Ø¹Ù†Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Process<br />
            â€¢ Ù‚Ø¨Ù„ Ø£ÙŠ Activity<br />
            â€¢ Ù…ÙƒØ§Ù† Ù…Ù…ØªØ§Ø² Ù„Ù„Ù€ Initialization<br />
            <br />
            <strong>2. onDestroy() Ù„ÙŠØ³ Ù…Ø¶Ù…ÙˆÙ†Ø§Ù‹!</strong><br />
            â€¢ Process Ù‚Ø¯ ÙŠÙÙ‚ØªÙ„ Ø¨Ù€ SIGKILL<br />
            â€¢ onDestroy() Ù„Ø§ ÙŠÙØ³ØªØ¯Ø¹Ù‰<br />
            â€¢ Ø§Ø­ÙØ¸ State ÙÙŠ onStop()ØŒ Ù„ÙŠØ³ onDestroy()<br />
            <br />
            <strong>3. Configuration Change = Full Recreation</strong><br />
            â€¢ Rotation â†’ onCreate() Ù…Ø±Ø© Ø£Ø®Ø±Ù‰<br />
            â€¢ Ù„ÙƒÙ† Process Ù†ÙØ³Ù‡ (Ù„Ø§ Application.onCreate())<br />
            <br />
            <strong>4. onSaveInstanceState() Ù‚Ø¯ Ù„Ø§ ÙŠÙØ³ØªØ¯Ø¹Ù‰</strong><br />
            â€¢ ÙŠÙØ³ØªØ¯Ø¹Ù‰ ÙÙ‚Ø· Ø¥Ø°Ø§ System ÙŠØ­ØªØ§Ø¬ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡<br />
            â€¢ Ù„Ø§ ÙŠÙØ³ØªØ¯Ø¹Ù‰ Ø¹Ù†Ø¯ Back button<br />
            â€¢ Ù„Ø§ ÙŠÙØ³ØªØ¯Ø¹Ù‰ Ø¹Ù†Ø¯ finish()
          </blockquote>

          <hr />

          <h2>Ø§Ù„ØªØ´Ø¨ÙŠÙ‡ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ: Ø§Ù„Ù…Ø³Ø±Ø­ ÙˆØ§Ù„Ù…Ù…Ø«Ù„ÙŠÙ† ğŸ­</h2>

          <h3>ØªØ®ÙŠÙ„ Android App ÙƒÙ…Ø³Ø±Ø­ÙŠØ©:</h3>

          <div dir="ltr">
            <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Theater (Android)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Theater Building (Process):                         â”‚
â”‚  â€¢ Ø§Ù„Ù…Ø¨Ù†Ù‰ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ (RAM space)                      â”‚
â”‚  â€¢ ÙŠÙØ¨Ù†Ù‰ Ø¹Ù†Ø¯ Ø£ÙˆÙ„ Ø¹Ø±Ø¶ (App launch)                   â”‚
â”‚  â€¢ ÙŠØ¨Ù‚Ù‰ Ù‚Ø§Ø¦Ù…Ø§Ù‹ Ø¨ÙŠÙ† Ø§Ù„Ø¹Ø±ÙˆØ¶ (Process cached)          â”‚
â”‚  â€¢ Ù‚Ø¯ ÙŠÙÙ‡Ø¯Ù… Ù„Ù„ØªÙˆÙÙŠØ± (Process killed)                 â”‚
â”‚                                                      â”‚
â”‚  Theater Management (Application):                   â”‚
â”‚  â€¢ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©                                   â”‚
â”‚  â€¢ Ù…ÙˆØ¬ÙˆØ¯Ø© Ø·ÙˆÙ„ Ø¹Ù…Ø± Ø§Ù„Ù…Ø¨Ù†Ù‰                             â”‚
â”‚  â€¢ ØªÙÙ†Ø´Ø£ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© (Application.onCreate())         â”‚
â”‚  â€¢ Global resources, Singletons                      â”‚
â”‚                                                      â”‚
â”‚  Stage (Activity):                                   â”‚
â”‚  â€¢ Ø§Ù„Ù…Ø³Ø±Ø­ Ù†ÙØ³Ù‡                                       â”‚
â”‚  â€¢ Ù…Ù…Ø«Ù„ ÙˆØ§Ø­Ø¯ ÙŠØ¹Ù…Ù„ ÙÙŠ ÙƒÙ„ Ù…Ø±Ø© (Foreground Activity)   â”‚
â”‚  â€¢ ÙŠØªØºÙŠØ± Ø­Ø³Ø¨ Ø§Ù„Ù…Ø´Ù‡Ø¯ (Activity navigation)           â”‚
â”‚  â€¢ Ù„Ù‡ Ø³ØªØ§Ø±Ø© (Window)                                â”‚
â”‚                                                      â”‚
â”‚  Actor (Fragment):                                   â”‚
â”‚  â€¢ Ø§Ù„Ù…Ù…Ø«Ù„ÙˆÙ† Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø±Ø­                               â”‚
â”‚  â€¢ Ù…ØªØ¹Ø¯Ø¯ÙˆÙ† Ø¹Ù„Ù‰ Ù†ÙØ³ Ø§Ù„Ù…Ø³Ø±Ø­                            â”‚
â”‚  â€¢ ÙŠØ¯Ø®Ù„ÙˆÙ† ÙˆÙŠØ®Ø±Ø¬ÙˆÙ† (FragmentTransaction)             â”‚
â”‚  â€¢ ÙŠØ¹ØªÙ…Ø¯ÙˆÙ† Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø±Ø­ (Activity Context)             â”‚
â”‚                                                      â”‚
â”‚  Props (Views):                                      â”‚
â”‚  â€¢ Ø§Ù„Ø¯ÙŠÙƒÙˆØ± ÙˆØ§Ù„Ø£Ø¯ÙˆØ§Øª                                  â”‚
â”‚  â€¢ ØªÙØ­Ø¶Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø© (inflation)                      â”‚
â”‚  â€¢ ØªÙØ²Ø§Ù„ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø´Ù‡Ø¯ (destroy)                  â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Scenarios:

1. First Show (Cold Start):
   â€¢ Build theater (Create Process) - Expensive! â±
   â€¢ Setup management (Application.onCreate())
   â€¢ Prepare stage (Activity.onCreate())
   â€¢ Actors enter (Fragment.onCreate())
   â€¢ Show begins (onResume())

2. Intermission (Home button):
   â€¢ Curtain closes (onPause())
   â€¢ Actors wait backstage (onStop())
   â€¢ Theater stays open (Process cached)
   â€¢ Management still there (Application alive)

3. Theater Demolished (Process killed):
   â€¢ Building destroyed (SIGKILL)
   â€¢ Everything gone instantly! â˜ ï¸
   â€¢ Actors have no chance to pack (no onDestroy)
   â€¢ Management lost (Application gone)

4. Show Resumes (Warm/Cold Start):
   â€¢ If theater exists: Quick resume âœ“
   â€¢ If demolished: Rebuild everything ğŸ’°

5. Scene Change (Configuration Change):
   â€¢ Tear down stage (Activity destroyed)
   â€¢ Rebuild stage (Activity recreated)
   â€¢ Theater stays (Process same)
   â€¢ Management same (Application same)</pre>
          </div>

          <blockquote>
            <strong>ğŸ¯ Ø§Ù„Ø¯Ø±ÙˆØ³:</strong><br />
            1. <strong>Process = Theater Building</strong> (Ø£Ø·ÙˆÙ„ Ø¹Ù…Ø±)<br />
            2. <strong>Application = Management</strong> (ÙŠØ¹ÙŠØ´ Ù…Ø¹ Process)<br />
            3. <strong>Activity = Stage</strong> (ÙŠØªØºÙŠØ± ÙƒØ«ÙŠØ±Ø§Ù‹)<br />
            4. <strong>Fragment = Actor</strong> (Ø£Ù‚ØµØ± Ø¹Ù…Ø±)<br />
            5. <strong>View = Props</strong> (ÙŠÙØ®Ù„Ù‚ ÙˆÙŠÙØ¯Ù…Ø± Ø¨Ø§Ø³ØªÙ…Ø±Ø§Ø±)<br />
            <br />
            <strong>â†’ ÙÙ‡Ù… Ø§Ù„Ù‡Ø±Ù…ÙŠØ© = Ù…ÙØªØ§Ø­ Android development!</strong>
          </blockquote>

          <hr />

          <h2>Activity Lifecycle Ø¨Ø§Ù„ØªÙØµÙŠÙ„ ğŸ“±</h2>

          <h3>Ø§Ù„Ù€ States Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:</h3>

          <div dir="ltr">
            <pre>Activity States:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LAUNCHED (Ù‚Ø¨Ù„ onCreate)                     â”‚
â”‚ â€¢ Activity object created                   â”‚
â”‚ â€¢ Constructor called                        â”‚
â”‚ â€¢ Members initialized                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CREATED (Ø¨Ø¹Ø¯ onCreate)                      â”‚
â”‚ â€¢ setContentView() called                   â”‚
â”‚ â€¢ Views inflated                            â”‚
â”‚ â€¢ findViewById() works                      â”‚
â”‚ â€¢ Invisible to user                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STARTED (Ø¨Ø¹Ø¯ onStart)                       â”‚
â”‚ â€¢ Activity visible                          â”‚
â”‚ â€¢ But not focused (can't interact)          â”‚
â”‚ â€¢ Example: Dialog in front                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RESUMED (Ø¨Ø¹Ø¯ onResume) âœ“ ACTIVE            â”‚
â”‚ â€¢ Fully visible                             â”‚
â”‚ â€¢ Has focus (user can interact)             â”‚
â”‚ â€¢ Receives input events                     â”‚
â”‚ â€¢ Drawing to screen                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ (User presses Home)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PAUSED (Ø¨Ø¹Ø¯ onPause)                        â”‚
â”‚ â€¢ Still visible (partially)                 â”‚
â”‚ â€¢ Lost focus (no input events)              â”‚
â”‚ â€¢ Can still draw                            â”‚
â”‚ â€¢ Example: PiP, Multi-window                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STOPPED (Ø¨Ø¹Ø¯ onStop)                        â”‚
â”‚ â€¢ Not visible                               â”‚
â”‚ â€¢ Process cached in background              â”‚
â”‚ â€¢ Can be killed by system!                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ (System kills Process)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DESTROYED (Ø¨Ø¹Ø¯ onDestroy... maybe)          â”‚
â”‚ â€¢ Activity finished                         â”‚
â”‚ â€¢ Memory released                           â”‚
â”‚ â€¢ Or killed without onDestroy!              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <h3>ÙƒÙ„ Callback Ø¨Ø§Ù„ØªÙØµÙŠÙ„:</h3>

          <h4>onCreate(Bundle savedInstanceState):</h4>

          <div dir="ltr">
            <pre>onCreate():
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ When called:                               â”‚
â”‚ â€¢ First time Activity created              â”‚
â”‚ â€¢ After configuration change (rotation)    â”‚
â”‚ â€¢ After process recreation                 â”‚
â”‚                                            â”‚
â”‚ What to do:                                â”‚
â”‚ âœ“ setContentView()                         â”‚
â”‚ âœ“ findViewById() / ViewBinding             â”‚
â”‚ âœ“ Initialize ViewModel                     â”‚
â”‚ âœ“ Setup RecyclerView adapters             â”‚
â”‚ âœ“ Restore state from savedInstanceState   â”‚
â”‚                                            â”‚
â”‚ What NOT to do:                            â”‚
â”‚ âŒ Start animations (not visible yet!)     â”‚
â”‚ âŒ Access camera/location (no permission)  â”‚
â”‚ âŒ Heavy computation (blocks UI)           â”‚
â”‚ âŒ Network requests on Main Thread         â”‚
â”‚                                            â”‚
â”‚ savedInstanceState:                        â”‚
â”‚ â€¢ null: First time                         â”‚
â”‚ â€¢ Bundle: Restoring state                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example:
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    private val viewModel: MainViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 1. Inflate layout
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        // 2. Setup UI
        binding.recyclerView.apply {
            layoutManager = LinearLayoutManager(context)
            adapter = MyAdapter()
        }
        
        // 3. Observe data
        viewModel.data.observe(this) { data ->
            // Update UI
        }
        
        // 4. Restore state (if needed)
        savedInstanceState?.let {
            val position = it.getInt("scroll_position")
            binding.recyclerView.scrollToPosition(position)
        }
        
        // Called once per creation âœ“
    }
}</pre>
          </div>

          <h4>onStart() & onStop():</h4>

          <div dir="ltr">
            <pre>onStart():
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ When called:                               â”‚
â”‚ â€¢ After onCreate()                         â”‚
â”‚ â€¢ After onRestart() (coming back)          â”‚
â”‚ â€¢ Activity becoming visible                â”‚
â”‚                                            â”‚
â”‚ What to do:                                â”‚
â”‚ âœ“ Register BroadcastReceivers              â”‚
â”‚ âœ“ Start lightweight animations             â”‚
â”‚ âœ“ Acquire resources (if cheap)             â”‚
â”‚                                            â”‚
â”‚ Note: Can be called MANY times!            â”‚
â”‚ (onCreate once, onStart multiple)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

onStop():
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ When called:                               â”‚
â”‚ â€¢ Activity no longer visible               â”‚
â”‚ â€¢ Home pressed                             â”‚
â”‚ â€¢ Another activity in front                â”‚
â”‚                                            â”‚
â”‚ What to do:                                â”‚
â”‚ âœ“ Unregister BroadcastReceivers            â”‚
â”‚ âœ“ Stop animations                          â”‚
â”‚ âœ“ Release heavy resources                  â”‚
â”‚ âœ“ Save data to database/SharedPrefs        â”‚
â”‚   (DON'T wait for onDestroy!)              â”‚
â”‚                                            â”‚
â”‚ CRITICAL: onDestroy() might NOT be called! â”‚
â”‚ â†’ Save state HERE, not in onDestroy()      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example:
class MainActivity : AppCompatActivity() {
    private lateinit var locationReceiver: BroadcastReceiver
    
    override fun onStart() {
        super.onStart()
        
        // Register receiver (when visible)
        val filter = IntentFilter(ACTION_LOCATION_UPDATE)
        registerReceiver(locationReceiver, filter)
    }
    
    override fun onStop() {
        super.onStop()
        
        // Unregister receiver (not visible)
        unregisterReceiver(locationReceiver)
        
        // Save important data NOW!
        viewModel.saveData()  // Don't wait for onDestroy
    }
}</pre>
          </div>

          <h4>onResume() & onPause():</h4>

          <div dir="ltr">
            <pre>onResume():
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ When called:                               â”‚
â”‚ â€¢ Activity in foreground                   â”‚
â”‚ â€¢ User can interact                        â”‚
â”‚ â€¢ Receives input events                    â”‚
â”‚                                            â”‚
â”‚ What to do:                                â”‚
â”‚ âœ“ Start camera preview                     â”‚
â”‚ âœ“ Resume video playback                    â”‚
â”‚ âœ“ Start sensor listening                   â”‚
â”‚ âœ“ Resume animations                        â”‚
â”‚                                            â”‚
â”‚ Called MANY times! (very frequent)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

onPause():
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ When called:                               â”‚
â”‚ â€¢ Lost focus (but might still be visible!) â”‚
â”‚ â€¢ Dialog appeared                          â”‚
â”‚ â€¢ PiP mode                                 â”‚
â”‚ â€¢ Multi-window partially covered           â”‚
â”‚                                            â”‚
â”‚ What to do:                                â”‚
â”‚ âœ“ Pause camera preview                     â”‚
â”‚ âœ“ Pause video playback                     â”‚
â”‚ âœ“ Stop sensor listening                    â”‚
â”‚ âœ“ Pause animations                         â”‚
â”‚                                            â”‚
â”‚ What NOT to do:                            â”‚
â”‚ âŒ Heavy operations (blocks transition!)   â”‚
â”‚ âŒ Save to database (too slow!)            â”‚
â”‚    â†’ Do it in onStop() instead             â”‚
â”‚                                            â”‚
â”‚ Rule: Keep it FAST! (< 50ms)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example:
class CameraActivity : AppCompatActivity() {
    private lateinit var camera: Camera
    
    override fun onResume() {
        super.onResume()
        
        // User back to this Activity - resume camera
        camera.startPreview()
    }
    
    override fun onPause() {
        super.onPause()
        
        // Lost focus - stop camera immediately
        // (Battery, privacy!)
        camera.stopPreview()
        
        // Keep it fast! ğŸƒ
    }
}</pre>
          </div>

          <h4>onSaveInstanceState() & onRestoreInstanceState():</h4>

          <div dir="ltr">
            <pre>onSaveInstanceState(Bundle outState):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ When called:                               â”‚
â”‚ â€¢ BEFORE onStop()                          â”‚
â”‚ â€¢ IF system MIGHT recreate Activity        â”‚
â”‚                                            â”‚
â”‚ Called when:                               â”‚
â”‚ âœ“ Configuration change (rotation)          â”‚
â”‚ âœ“ Home button (might be killed)            â”‚
â”‚ âœ“ Recent apps switch                       â”‚
â”‚                                            â”‚
â”‚ NOT called when:                           â”‚
â”‚ âŒ Back button (user finishing)            â”‚
â”‚ âŒ finish() called explicitly              â”‚
â”‚                                            â”‚
â”‚ What to save:                              â”‚
â”‚ â€¢ Transient UI state                       â”‚
â”‚ â€¢ User input not yet committed             â”‚
â”‚ â€¢ Scroll positions                         â”‚
â”‚ â€¢ Selected items                           â”‚
â”‚                                            â”‚
â”‚ What NOT to save:                          â”‚
â”‚ â€¢ Large objects (> 1 MB)                   â”‚
â”‚ â€¢ Bitmaps (use ViewModel)                  â”‚
â”‚ â€¢ Complex objects (use ViewModel)          â”‚
â”‚                                            â”‚
â”‚ Size limit: ~1 MB (TransactionTooLarge!)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example:
class MainActivity : AppCompatActivity() {
    private var userInput: String = ""
    private var scrollPosition: Int = 0
    
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        
        // Save UI state
        outState.putString("user_input", userInput)
        outState.putInt("scroll_position", scrollPosition)
        
        // Small data only! âœ“
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Restore state
        savedInstanceState?.let {
            userInput = it.getString("user_input", "")
            scrollPosition = it.getInt("scroll_position", 0)
        }
    }
    
    // Or use this (called after onStart):
    override fun onRestoreInstanceState(savedInstanceState: Bundle) {
        super.onRestoreInstanceState(savedInstanceState)
        
        // Same as onCreate, but cleaner
        userInput = savedInstanceState.getString("user_input", "")
        scrollPosition = savedInstanceState.getInt("scroll_position", 0)
    }
}</pre>
          </div>

          <h3>Common Mistakes:</h3>

          <div class="warning">
            <strong>âŒ Ø£Ø®Ø·Ø§Ø¡ Ø´Ø§Ø¦Ø¹Ø© ÙÙŠ Lifecycle:</strong><br />
            <br />
            <strong>1. Ø¥Ù‡Ù…Ø§Ù„ onStop():</strong><br />
            â€¢ Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ onDestroy() ÙÙ‚Ø·<br />
            â€¢ onDestroy() Ù‚Ø¯ Ù„Ø§ ÙŠÙØ³ØªØ¯Ø¹Ù‰!<br />
            â€¢ Ø§Ù„Ù†ØªÙŠØ¬Ø©: ÙÙ‚Ø¯Ø§Ù† Ø¨ÙŠØ§Ù†Ø§Øª User<br />
            <br />
            <strong>2. Ø¹Ù…Ù„ Ø¨Ø·ÙŠØ¡ ÙÙŠ onPause():</strong><br />
            â€¢ Database write ÙÙŠ onPause()<br />
            â€¢ ÙŠØ¹Ø·Ù„ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ (lag Ù…Ù„Ø­ÙˆØ¸)<br />
            â€¢ Ø§ÙØ¹Ù„Ù‡Ø§ ÙÙŠ onStop() Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù†Ù‡<br />
            <br />
            <strong>3. Ù†Ø³ÙŠØ§Ù† Unregister:</strong><br />
            â€¢ Register ÙÙŠ onCreate()<br />
            â€¢ Ù†Ø³ÙŠØ§Ù† Unregister ÙÙŠ onDestroy()<br />
            â€¢ Ø§Ù„Ù†ØªÙŠØ¬Ø©: Memory leak!<br />
            <br />
            <strong>4. Ø¥Ø³Ø§Ø¡Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… savedInstanceState:</strong><br />
            â€¢ Ø­ÙØ¸ Bitmap ÙƒØ¨ÙŠØ± (Crash!)<br />
            â€¢ Ø­ÙØ¸ ÙƒØ§Ø¦Ù†Ø§Øª Ù…Ø¹Ù‚Ø¯Ø©<br />
            â€¢ TransactionTooLargeException<br />
            <br />
            <strong>5. ØªØ¬Ø§Ù‡Ù„ Configuration Changes:</strong><br />
            â€¢ Store references ÙÙŠ Static<br />
            â€¢ Activity leak Ø¹Ù†Ø¯ Rotation<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… ViewModel Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù†Ù‡!
          </div>

          <hr />

          <h2>Fragment Lifecycle Ø§Ù„Ù…Ø¹Ù‚Ø¯ ğŸ§©</h2>

          <h3>Ù„Ù…Ø§Ø°Ø§ Fragment Lifecycle Ù…Ø¹Ù‚Ø¯ØŸ</h3>

          <blockquote>
            <strong>Fragment Lifecycle = Activity Lifecycle + Extra Steps</strong><br />
            <br />
            Fragment ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Activity:<br />
            â€¢ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠØ¹ÙŠØ´ Ø¨Ù…ÙØ±Ø¯Ù‡<br />
            â€¢ ÙŠÙ…Ø± Ø¨Ù€ Lifecycle Ø®Ø§Øµ Ø¨Ù‡<br />
            â€¢ Ø«Ù… ÙŠØªØ¨Ø¹ Activity Lifecycle<br />
            <br />
            <strong>â†’ Lifecycle Ù…ØªØ¯Ø§Ø®Ù„ = ØªØ¹Ù‚ÙŠØ¯!</strong>
          </blockquote>

          <h3>Fragment States:</h3>

          <div dir="ltr">
            <pre>Fragment Lifecycle (Full):

1. onAttach(Context)
   â†“ Fragment attached to Activity
2. onCreate(Bundle)
   â†“ Fragment created
3. onCreateView(LayoutInflater, ViewGroup, Bundle)
   â†“ Inflate layout, return View
4. onViewCreated(View, Bundle)
   â†“ View ready, can access child views
5. onActivityCreated(Bundle) [Deprecated!]
   â†“ Activity's onCreate finished
6. onStart()
   â†“ Fragment visible
7. onResume()
   â†“ Fragment active (can interact)

   â”€â”€â”€ User presses Home â”€â”€â”€

8. onPause()
   â†“ Lost focus
9. onStop()
   â†“ Not visible
10. onDestroyView()
    â†“ View destroyed (but Fragment still exists!)
11. onDestroy()
    â†“ Fragment destroyed
12. onDetach()
    â†“ Fragment detached from Activity

Key Difference from Activity:
â€¢ onCreateView() â†’ onCreate() equivalent for Views
â€¢ onViewCreated() â†’ Best place to access Views
â€¢ onDestroyView() â†’ Views destroyed, Fragment still alive!
  (Important for View cleanup)</pre>
          </div>

          <h3>Fragment vs Activity Lifecycle:</h3>

          <div dir="ltr">
            <pre>When Activity goes through Lifecycle:

Activity.onCreate()
â”œâ”€â†’ Fragment.onAttach()
â”œâ”€â†’ Fragment.onCreate()
â”œâ”€â†’ Fragment.onCreateView()
â”œâ”€â†’ Fragment.onViewCreated()
â””â”€â†’ Fragment.onActivityCreated()

Activity.onStart()
â””â”€â†’ Fragment.onStart()

Activity.onResume()
â””â”€â†’ Fragment.onResume()

â”€â”€â”€ User presses Home â”€â”€â”€

Activity.onPause()
â””â”€â†’ Fragment.onPause()

Activity.onStop()
â””â”€â†’ Fragment.onStop()

Activity.onDestroy()
â”œâ”€â†’ Fragment.onDestroyView()
â”œâ”€â†’ Fragment.onDestroy()
â””â”€â†’ Fragment.onDetach()

Note: Fragment lifecycle is SYNCHRONIZED with Activity!</pre>
          </div>

          <h3>Fragment Transactions (Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ!):</h3>

          <div dir="ltr">
            <pre>Fragment Transactions affect Lifecycle:

1. add():
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ onAttach â†’ onCreate â†’ onCreateView â”‚
   â”‚ â†’ onViewCreated â†’ onStart â†’ onResumeâ”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. replace():
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Old Fragment:                      â”‚
   â”‚ onPause â†’ onStop â†’ onDestroyView   â”‚
   â”‚ â†’ onDestroy â†’ onDetach             â”‚
   â”‚                                    â”‚
   â”‚ New Fragment:                      â”‚
   â”‚ onAttach â†’ onCreate â†’ ...          â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. replace() + addToBackStack():
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Old Fragment:                      â”‚
   â”‚ onPause â†’ onStop â†’ onDestroyView   â”‚
   â”‚ (but NOT onDestroy!) âš ï¸            â”‚
   â”‚ Fragment kept in BackStack         â”‚
   â”‚                                    â”‚
   â”‚ When Back pressed:                 â”‚
   â”‚ onCreateView â†’ onViewCreated       â”‚
   â”‚ â†’ onStart â†’ onResume               â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4. hide():
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Fragment: setVisibility(GONE)      â”‚
   â”‚ No Lifecycle callbacks!            â”‚
   â”‚ Fragment still RESUMED!            â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5. detach():
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ onPause â†’ onStop â†’ onDestroyView   â”‚
   â”‚ (but NOT onDestroy!)               â”‚
   â”‚ Fragment exists without View       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <h3>ViewLifecycleOwner (Ø§Ù„Ø¬Ø¯ÙŠØ¯ ÙˆØ§Ù„Ù…Ù‡Ù…!):</h3>

          <div dir="ltr">
            <pre>Fragment has TWO Lifecycles:

1. Fragment Lifecycle (this.lifecycle):
   â€¢ Lives from onAttach to onDetach
   â€¢ Survives BackStack
   â€¢ Longer lifetime

2. View Lifecycle (viewLifecycleOwner.lifecycle):
   â€¢ Lives from onCreateView to onDestroyView
   â€¢ Destroyed when Fragment in BackStack!
   â€¢ Shorter lifetime

Problem with Fragment lifecycle:
// âŒ Wrong! Memory leak if Fragment in BackStack
viewModel.data.observe(this) { data ->  // 'this' = Fragment
    textView.text = data  // textView is null after onDestroyView!
}

Solution with ViewLifecycleOwner:
// âœ… Correct! Automatically unsubscribed
viewModel.data.observe(viewLifecycleOwner) { data ->
    textView.text = data  // Safe! âœ“
}

Rule: Always use viewLifecycleOwner in Fragment!</pre>
          </div>

          <div class="warning">
            <strong>âš ï¸ Fragment Lifecycle Pitfalls:</strong><br />
            <br />
            <strong>1. Accessing Views after onDestroyView:</strong><br />
            â€¢ Fragment still exists<br />
            â€¢ But Views = null!<br />
            â€¢ Crash: NullPointerException<br />
            <br />
            <strong>2. Using 'this' instead of 'viewLifecycleOwner':</strong><br />
            â€¢ Observer not removed after onDestroyView<br />
            â€¢ Memory leak<br />
            â€¢ Crash when accessing destroyed Views<br />
            <br />
            <strong>3. Fragment in BackStack confusion:</strong><br />
            â€¢ onDestroy() NOT called<br />
            â€¢ Fragment still in memory<br />
            â€¢ Views destroyed (onDestroyView called)<br />
            <br />
            <strong>4. Nested Fragments:</strong><br />
            â€¢ Parent Fragment destroyed<br />
            â€¢ Child Fragments also destroyed<br />
            â€¢ Use childFragmentManager carefully!
          </div>

          <hr />

          <h2>Process Lifecycle (Ø§Ù„Ø£Ù‡Ù…!) âš™ï¸</h2>

          <h3>Ù„Ù…Ø§Ø°Ø§ Process Lifecycle Ø£Ù‡Ù… Ù…Ù† Activity LifecycleØŸ</h3>

          <blockquote>
            <strong>Ø§Ù„Ø­Ù‚ÙŠÙ‚Ø© Ø§Ù„Ù‚Ø§Ø³ÙŠØ©:</strong><br />
            Activity Lifecycle = ÙˆÙ‡Ù… Ù†Ø³Ø¨ÙŠ<br />
            Process Lifecycle = Ø§Ù„ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø·Ù„Ù‚<br />
            <br />
            â€¢ Activity Ù‚Ø¯ ÙŠÙØ¯Ù…Ø± ÙˆÙŠÙØ¹Ø§Ø¯ Ø¨Ù†Ø§Ø¤Ù‡ (rotation)<br />
            â€¢ Ù„ÙƒÙ† Process ÙŠØ¨Ù‚Ù‰ Ø­ÙŠØ§Ù‹<br />
            â€¢ Application object ÙŠØ¨Ù‚Ù‰ Ø­ÙŠØ§Ù‹<br />
            â€¢ Singletons ØªØ¨Ù‚Ù‰ Ø­ÙŠØ©<br />
            â€¢ Static variables ØªØ¨Ù‚Ù‰ Ø­ÙŠØ©<br />
            <br />
            <strong>â†’ Process Lifecycle ÙŠØ­Ø¯Ø¯ Ù…ØªÙ‰ ÙŠÙÙ…Ø³Ø­ ÙƒÙ„ Ø´ÙŠØ¡ ÙØ¹Ù„Ø§Ù‹!</strong>
          </blockquote>

          <h3>Process States:</h3>

          <div dir="ltr">
            <pre>Process Lifecycle:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. NOT CREATED                              â”‚
â”‚    â€¢ App never launched                     â”‚
â”‚    â€¢ Or killed and cleared from memory      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ User launches App
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. CREATED (Cold Start)                     â”‚
â”‚    â€¢ Zygote forks new Process               â”‚
â”‚    â€¢ Application.onCreate() called âš¡       â”‚
â”‚    â€¢ Takes 500-2000ms                       â”‚
â”‚    â€¢ User sees splash/blank screen          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. FOREGROUND (High Priority)               â”‚
â”‚    â€¢ User interacting with App              â”‚
â”‚    â€¢ OOM Adj: -800                          â”‚
â”‚    â€¢ Won't be killed (unless desperate)     â”‚
â”‚    â€¢ Full CPU, Memory access                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ User presses Home
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. BACKGROUND (Medium Priority)             â”‚
â”‚    â€¢ App not visible                        â”‚
â”‚    â€¢ OOM Adj: 400-900                       â”‚
â”‚    â€¢ Can be killed anytime!                 â”‚
â”‚    â€¢ CPU throttled, Network restricted      â”‚
â”‚    â€¢ Service: 5-minute time limit           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ Not used for 30 min
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. CACHED (Low Priority)                    â”‚
â”‚    â€¢ Empty Process (no active components)   â”‚
â”‚    â€¢ OOM Adj: 900-1000                      â”‚
â”‚    â€¢ Kept for fast restart                  â”‚
â”‚    â€¢ Killed immediately if RAM needed       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ Low Memory
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. KILLED                                   â”‚
â”‚    â€¢ SIGKILL received                       â”‚
â”‚    â€¢ Process dies instantly                 â”‚
â”‚    â€¢ Application.onTerminate() NOT called!  â”‚
â”‚    â€¢ All memory released                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ User returns
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 7. RECREATED (Cold Start again)             â”‚
â”‚    â€¢ New Process created                    â”‚
â”‚    â€¢ Application.onCreate() called again    â”‚
â”‚    â€¢ Activity.onCreate(savedInstanceState)  â”‚
â”‚    â€¢ Feels slower to user                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <h3>Application.onCreate() - Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø­Ø±Ø¬Ø©:</h3>

          <div dir="ltr">
            <pre>Application.onCreate():
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ When called:                               â”‚
â”‚ â€¢ Once per Process lifetime                â”‚
â”‚ â€¢ Before any Activity                      â”‚
â”‚ â€¢ Before any Service                       â”‚
â”‚ â€¢ On Main Thread!                          â”‚
â”‚                                            â”‚
â”‚ What to do:                                â”‚
â”‚ âœ“ Initialize global objects                â”‚
â”‚ âœ“ Setup crash reporting (Firebase)        â”‚
â”‚ âœ“ Initialize analytics                     â”‚
â”‚ âœ“ Setup DI framework (Dagger/Koin/Hilt)   â”‚
â”‚ âœ“ Initialize libraries (Glide, Timber)    â”‚
â”‚                                            â”‚
â”‚ What NOT to do:                            â”‚
â”‚ âŒ Heavy computation (blocks UI!)          â”‚
â”‚ âŒ Synchronous network (ANR!)              â”‚
â”‚ âŒ Large file I/O (slow!)                  â”‚
â”‚ âŒ Database migrations (move to background)â”‚
â”‚                                            â”‚
â”‚ Keep it FAST! (< 100ms ideal)              â”‚
â”‚ Every ms here = app launch delay           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Example:
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // Fast initialization only!
        Timber.plant(Timber.DebugTree())
        
        // Heavy work: move to background
        GlobalScope.launch(Dispatchers.IO) {
            initializeHeavyLibrary()
        }
        
        // Setup DI
        startKoin {
            androidContext(this@MyApp)
            modules(appModule)
        }
    }
}

Application.onTerminate():
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ NEVER CALLED on real devices!              â”‚
â”‚ Only in emulator during shutdown           â”‚
â”‚ Don't rely on it!                          â”‚
â”‚                                            â”‚
â”‚ â†’ No cleanup happens on Process kill       â”‚
â”‚ â†’ Everything just disappears (SIGKILL)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <hr />

          <h2>Ù…Ø§ Ù‡Ùˆ ContextØŸ ğŸ¯</h2>

          <h3>Ø§Ù„ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ:</h3>

          <blockquote>
            <strong>Context:</strong><br />
            "Ø¨ÙˆØ§Ø¨Ø© Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù…ÙˆØ§Ø±Ø¯ Android Ùˆ System Services"<br />
            <br />
            Ø¨Ø¯ÙˆÙ† ContextØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ:<br />
            â€¢ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù€ Resources (strings, drawables, colors)<br />
            â€¢ Ø¥Ù†Ø´Ø§Ø¡ Views<br />
            â€¢ Start Activities/Services<br />
            â€¢ Access System Services (LocationManager, NotificationManager)<br />
            â€¢ Access SharedPreferences, Databases<br />
            â€¢ Send Broadcasts<br />
            <br />
            <strong>â†’ Context = Ø§Ù„Ù…ÙØªØ§Ø­ Ù„ÙƒÙ„ Ø´ÙŠØ¡ ÙÙŠ Android!</strong>
          </blockquote>

          <h3>Context Hierarchy:</h3>

          <div dir="ltr">
            <pre>Context Inheritance:

                    Context (abstract)
                        â†‘
                        â”‚
                ContextWrapper (abstract)
                        â†‘
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                               â”‚
    Application                     ContextThemeWrapper
    (Singleton)                             â†‘
                                            â”‚
                                        Activity
                                        (Multiple)

What this means:
â€¢ Application IS-A Context (via ContextWrapper)
â€¢ Activity IS-A Context (via ContextThemeWrapper)
â€¢ Service IS-A Context (via ContextWrapper)

But:
â€¢ Fragment is NOT a Context!
  â€¢ Fragment.requireContext() â†’ Activity Context
  â€¢ Fragment.requireActivity() â†’ Activity

â€¢ View is NOT a Context!
  â€¢ View.getContext() â†’ Activity Context (usually)</pre>
          </div>

          <h3>Ù…Ø§Ø°Ø§ ÙŠØ­ØªÙˆÙŠ ContextØŸ</h3>

          <div dir="ltr">
            <pre>Context capabilities:

1. Resources:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ getString(R.string.app_name)       â”‚
   â”‚ getDrawable(R.drawable.icon)       â”‚
   â”‚ getColor(R.color.primary)          â”‚
   â”‚ getDimension(R.dimen.padding)      â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. System Services:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ getSystemService(LAYOUT_INFLATER)  â”‚
   â”‚ getSystemService(LOCATION_SERVICE) â”‚
   â”‚ getSystemService(NOTIFICATION_...)â”‚
   â”‚ getSystemService(ALARM_SERVICE)    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. Application Info:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ getPackageName()                   â”‚
   â”‚ getApplicationInfo()               â”‚
   â”‚ getApplicationContext()            â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4. File System:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ getFilesDir()                      â”‚
   â”‚ getCacheDir()                      â”‚
   â”‚ openFileInput()                    â”‚
   â”‚ openFileOutput()                   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5. Database:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ getDatabasePath()                  â”‚
   â”‚ openOrCreateDatabase()             â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

6. SharedPreferences:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ getSharedPreferences()             â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

7. Components:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ startActivity(Intent)              â”‚
   â”‚ startService(Intent)               â”‚
   â”‚ sendBroadcast(Intent)              â”‚
   â”‚ bindService()                      â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

8. Permissions:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ checkPermission()                  â”‚
   â”‚ checkSelfPermission()              â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <hr />

          <h2>Application Context vs Activity Context ğŸ”€</h2>

          <h3>Ø§Ù„ÙØ±Ù‚ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ø¬Ø§Ù†Ø¨</th>
                <th>Application Context</th>
                <th>Activity Context</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Lifetime</strong></td>
                <td>Process lifetime (Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹)</td>
                <td>Activity lifetime (Ù‚ØµÙŠØ±)</td>
              </tr>
              <tr>
                <td><strong>Ø¹Ø¯Ø¯ Ø§Ù„Ù€ Instances</strong></td>
                <td>ÙˆØ§Ø­Ø¯ ÙÙ‚Ø· (Singleton)</td>
                <td>Ù…ØªØ¹Ø¯Ø¯ (ÙƒÙ„ Activity Ù…Ø®ØªÙ„Ù)</td>
              </tr>
              <tr>
                <td><strong>Theme Support</strong></td>
                <td>Ù„Ø§ âŒ (No Theme)</td>
                <td>Ù†Ø¹Ù… âœ“ (Has Theme)</td>
              </tr>
              <tr>
                <td><strong>UI Creation</strong></td>
                <td>Ù…Ø­Ø¯ÙˆØ¯ (ÙŠÙ…ÙƒÙ† Ù„ÙƒÙ† ØºÙŠØ± Ù…Ø³ØªØ­Ø³Ù†)</td>
                <td>Ù†Ø¹Ù… âœ“ (Ø§Ù„Ù…ÙƒØ§Ù† Ø§Ù„ØµØ­ÙŠØ­)</td>
              </tr>
              <tr>
                <td><strong>Start Activity</strong></td>
                <td>Ù†Ø¹Ù… (Ù„ÙƒÙ† ÙŠØ­ØªØ§Ø¬ FLAG_ACTIVITY_NEW_TASK)</td>
                <td>Ù†Ø¹Ù… âœ“ (Ù…Ø¨Ø§Ø´Ø±)</td>
              </tr>
              <tr>
                <td><strong>Ø§Ù„ÙˆØµÙˆÙ„</strong></td>
                <td>applicationContext Ø£Ùˆ getApplicationContext()</td>
                <td>this ÙÙŠ Activity</td>
              </tr>
              <tr>
                <td><strong>Memory Leak Risk</strong></td>
                <td>Ù…Ù†Ø®ÙØ¶ (ÙŠØ¹ÙŠØ´ Ø·ÙˆÙŠÙ„Ø§Ù‹)</td>
                <td>Ø¹Ø§Ù„ÙŠ! (Ù‚Ø¯ ÙŠÙØ­ØªÙØ¸ Ø¨Ù‡ Ø¨Ø§Ù„Ø®Ø·Ø£)</td>
              </tr>
            </tbody>
          </table>

          <h3>Application Context Ø¨Ø§Ù„ØªÙØµÙŠÙ„:</h3>

          <div dir="ltr">
            <pre>Application Context:

Characteristics:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Singleton (one per Process)              â”‚
â”‚ â€¢ Lives entire Process lifetime            â”‚
â”‚ â€¢ Same object everywhere:                  â”‚
â”‚   activity.applicationContext === app      â”‚
â”‚   service.applicationContext === app       â”‚
â”‚ â€¢ No Theme attached                        â”‚
â”‚ â€¢ Survives Activity recreation             â”‚
â”‚ â€¢ Survives Configuration changes           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

When to use:
âœ“ Singletons (no Activity reference!)
âœ“ Registering BroadcastReceivers (application-wide)
âœ“ Accessing SharedPreferences
âœ“ Accessing databases
âœ“ Starting Services
âœ“ Long-lived objects (cache, repository)

When NOT to use:
âŒ Creating UI (no Theme!)
âŒ Showing Dialogs (needs Activity!)
âŒ Inflating Layouts (Theme issues)
âŒ Starting Activity without FLAG_ACTIVITY_NEW_TASK

Example:
class Repository(private val context: Context) {
    // âœ… Use Application Context for DB
    private val db = Room.databaseBuilder(
        context.applicationContext,  // Not Activity!
        AppDatabase::class.java,
        "database"
    ).build()
    
    // âœ… Safe! DB lives entire app lifetime
}</pre>
          </div>

          <h3>Activity Context Ø¨Ø§Ù„ØªÙØµÙŠÙ„:</h3>

          <div dir="ltr">
            <pre>Activity Context:

Characteristics:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Multiple instances (one per Activity)    â”‚
â”‚ â€¢ Lives only during Activity lifetime      â”‚
â”‚ â€¢ Has Theme (for styling)                  â”‚
â”‚ â€¢ Destroyed on rotation/recreation         â”‚
â”‚ â€¢ Different object after recreation!       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

When to use:
âœ“ Creating Views (needs Theme!)
âœ“ Showing Dialogs
âœ“ Inflating Layouts
âœ“ Starting Activities
âœ“ Accessing Activity-specific resources
âœ“ Getting WindowManager
âœ“ Anything UI-related

When NOT to use:
âŒ Storing in Singletons (Memory leak!)
âŒ Storing in static fields (Memory leak!)
âŒ Passing to background threads (Memory leak!)
âŒ Long-lived objects (Memory leak!)

Example - Memory Leak:
// âŒ MEMORY LEAK!
class DataManager {
    companion object {
        private var context: Context? = null
        
        fun init(context: Context) {
            this.context = context  // â˜ ï¸ Leak!
        }
    }
}

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        DataManager.init(this)  // âŒ Activity leaked!
        // After rotation, old Activity can't be GC'd
    }
}


// âœ… Fixed: Use Application Context
class DataManager {
    companion object {
        private var context: Context? = null
        
        fun init(context: Context) {
            this.context = context.applicationContext  // âœ“ Safe!
        }
    }
}</pre>
          </div>

          <hr />

          <h2>Ù…ØªÙ‰ ØªØ³ØªØ®Ø¯Ù… Ø£ÙŠ ContextØŸ ğŸ¤”</h2>

          <h3>Decision Tree:</h3>

          <div dir="ltr">
            <pre>Which Context to use?

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Do you need to create UI?              â”‚
â”‚ (View, Dialog, Layout inflation)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ YES     â”‚ NO
    â†“         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Activityâ”‚  â”‚ Is this a Singleton or     â”‚
â”‚Context â”‚  â”‚ long-lived object?         â”‚
â”‚âœ“       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
              â”‚ YES         â”‚ NO
              â†“             â†“
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚Applicationâ”‚    â”‚ Either   â”‚
       â”‚Context    â”‚    â”‚ works    â”‚
       â”‚âœ“          â”‚    â”‚ (prefer  â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ Activity)â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
          </div>

          <h3>Examples:</h3>

          <div dir="ltr">
            <pre>Scenario-based Examples:

1. Creating a Toast:
   Toast.makeText(this, "Hello", Toast.LENGTH_SHORT)
   // 'this' = Activity Context âœ“
   // Or applicationContext (works but not ideal)

2. Starting an Activity:
   startActivity(Intent(this, MainActivity::class.java))
   // 'this' = Activity Context âœ“ (best)
   // applicationContext needs FLAG_ACTIVITY_NEW_TASK

3. Showing a Dialog:
   AlertDialog.Builder(this)  // MUST be Activity!
   // âŒ applicationContext â†’ Crash!

4. Inflating a Layout:
   LayoutInflater.from(this).inflate(R.layout.item, parent, false)
   // 'this' = Activity Context âœ“ (for correct Theme)

5. Accessing SharedPreferences:
   getSharedPreferences("prefs", MODE_PRIVATE)
   // Either works
   // Prefer applicationContext (survives rotation)

6. Creating Database:
   Room.databaseBuilder(applicationContext, ...)
   // âœ“ Application Context (singleton nature)

7. Registering BroadcastReceiver (global):
   applicationContext.registerReceiver(receiver, filter)
   // âœ“ Application Context (lives entire app)

8. Getting System Service:
   val notificationManager = getSystemService(
       Context.NOTIFICATION_SERVICE
   ) as NotificationManager
   // Either works (same result)

9. Singleton initialization:
   object ImageLoader {
       fun init(context: Context) {
           appContext = context.applicationContext  // âœ“
       }
   }

10. Repository pattern:
    class UserRepository(context: Context) {
        private val appContext = context.applicationContext
        // âœ“ Store Application Context, not Activity
    }</pre>
          </div>

          <h3>Golden Rules:</h3>

          <div class="success">
            <strong>âœ… Ù‚ÙˆØ§Ø¹Ø¯ Context Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©:</strong><br />
            <br />
            <strong>1. UI = Activity Context</strong><br />
            â€¢ Views, Dialogs, Layouts<br />
            â€¢ Anything visual<br />
            <br />
            <strong>2. Singletons = Application Context</strong><br />
            â€¢ Database, Repository, Cache<br />
            â€¢ Long-lived objects<br />
            <br />
            <strong>3. Ù„Ø§ ØªØ®Ø²Ù† Activity Context ÙÙŠ:</strong><br />
            â€¢ Static fields<br />
            â€¢ Singletons<br />
            â€¢ Long-lived objects<br />
            â€¢ Background threads<br />
            <br />
            <strong>4. Ø¥Ø°Ø§ Ø´ÙƒÙƒØª:</strong><br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… Application Context<br />
            â€¢ Ø£ÙƒØ«Ø± Ø£Ù…Ø§Ù†Ø§Ù‹ (no leaks)<br />
            <br />
            <strong>5. Fragment:</strong><br />
            â€¢ requireContext() â†’ Activity Context<br />
            â€¢ requireActivity().applicationContext â†’ App Context
          </div>

          <hr />

          <h2>Context Leaks: Ø§Ù„ÙƒØ§Ø¨ÙˆØ³! ğŸ’€</h2>

          <h3>Ù…Ø§ Ù‡Ùˆ Context LeakØŸ</h3>

          <blockquote>
            <strong>Context Leak:</strong> Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ù€ reference Ù„Ù€ Activity Context Ø¨Ø¹Ø¯ destroy<br />
            <br />
            Ø§Ù„Ù†ØªÙŠØ¬Ø©:<br />
            â€¢ Activity Ù„Ø§ ÙŠÙ…ÙƒÙ† garbage collection<br />
            â€¢ ÙƒÙ„ ViewsØŒ BitmapsØŒ Resources ØªØ¨Ù‚Ù‰ ÙÙŠ Memory<br />
            â€¢ Memory leak: 50-100 MB per Activity!<br />
            â€¢ Ø¨Ø¹Ø¯ Ø¹Ø¯Ø© Rotations â†’ OutOfMemoryError<br />
            <br />
            <strong>â†’ Context Leak Ø£Ø®Ø·Ø± leak ÙÙŠ Android!</strong>
          </blockquote>

          <h3>Ø£Ù…Ø«Ù„Ø© Context Leaks:</h3>

          <h4>Leak 1: Static Reference:</h4>

          <div dir="ltr">
            <pre>// âŒ MASSIVE LEAK!
class LeakyActivity : AppCompatActivity() {
    companion object {
        var activity: Activity? = null  // â˜ ï¸
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        activity = this  // Leaking Activity!
    }
}

// User rotates screen 10 times
// â†’ 10 Activity instances in memory!
// â†’ 10 * 50 MB = 500 MB leak!


// âœ… Fixed: Don't store Activity in static
// If you really need it:
companion object {
    var activity: WeakReference<Activity>? = null
    
    fun setActivity(activity: Activity) {
        this.activity = WeakReference(activity)
    }
}</pre>
          </div>

          <h4>Leak 2: Singleton with Activity Context:</h4>

          <div dir="ltr">
            <pre>// âŒ LEAK!
object ImageCache {
    private lateinit var context: Context
    private val cache = LruCache<String, Bitmap>(...)
    
    fun init(context: Context) {
        this.context = context  // â˜ ï¸ If Activity Context
    }
    
    fun loadImage(url: String): Bitmap {
        // Uses context...
    }
}

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        ImageCache.init(this)  // âŒ Leaking Activity!
    }
}


// âœ… Fixed: Use Application Context
object ImageCache {
    private lateinit var context: Context
    
    fun init(context: Context) {
        this.context = context.applicationContext  // âœ“
    }
}</pre>
          </div>

          <h4>Leak 3: Background Thread:</h4>

          <div dir="ltr">
            <pre>// âŒ LEAK!
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Thread {
            Thread.sleep(10000)  // 10 seconds
            
            // 'this' captures Activity!
            runOnUiThread {
                textView.text = "Done"  // â˜ ï¸
            }
        }.start()
        
        // User rotates after 1 second
        // Thread keeps old Activity alive for 9 more seconds!
    }
}


// âœ… Fixed: WeakReference
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        val activityRef = WeakReference(this)
        
        Thread {
            Thread.sleep(10000)
            
            activityRef.get()?.runOnUiThread {
                textView.text = "Done"
            } // âœ“ Returns null if Activity destroyed
        }.start()
    }
}


// âœ… Ø£ÙØ¶Ù„: Coroutines + Lifecycle
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            delay(10000)
            textView.text = "Done"
        }
        // Automatically cancelled on destroy! âœ“
    }
}</pre>
          </div>

          <h4>Leak 4: Inner Class:</h4>

          <div dir="ltr">
            <pre>// âŒ LEAK!
class MainActivity : AppCompatActivity() {
    
    private val handler = Handler(Looper.getMainLooper())
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Inner class holds implicit reference to Activity!
        handler.postDelayed(object : Runnable {
            override fun run() {
                textView.text = "Updated"  // â˜ ï¸
                handler.postDelayed(this, 1000)  // Repeat
            }
        }, 1000)
        
        // Runnable keeps Activity alive forever!
    }
}


// âœ… Fixed: Static inner class + WeakReference
class MainActivity : AppCompatActivity() {
    
    private val handler = Handler(Looper.getMainLooper())
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        handler.postDelayed(UpdateRunnable(this), 1000)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        handler.removeCallbacksAndMessages(null)  // âœ“ Clean up!
    }
    
    // Static inner class - no implicit reference
    private class UpdateRunnable(activity: MainActivity) : Runnable {
        private val activityRef = WeakReference(activity)
        
        override fun run() {
            val activity = activityRef.get()
            if (activity != null && !activity.isFinishing) {
                activity.textView.text = "Updated"
                activity.handler.postDelayed(this, 1000)
            }
        }
    }
}</pre>
          </div>

          <h3>ÙƒÙŠÙ ØªÙƒØªØ´Ù Context LeaksØŸ</h3>

          <div dir="ltr">
            <pre>Detection Tools:

1. LeakCanary (Best!):
   dependencies {
       debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.12'
   }
   
   // Automatically detects leaks!
   // Shows notification with leak trace
   // Points to exact line causing leak âœ“

2. Android Studio Profiler:
   â€¢ Run app
   â€¢ Rotate screen 5-10 times
   â€¢ Force GC (garbage collect) button
   â€¢ Heap Dump
   â€¢ Search for Activity instances
   â€¢ Should be 1, not 10! âš ï¸

3. Manual check:
   override fun onDestroy() {
       super.onDestroy()
       Log.d("Lifecycle", "Activity destroyed: $this")
   }
   
   // Rotate screen
   // Check logs: should see destroy messages
   // If not destroyed after rotation â†’ Leak!</pre>
          </div>

          <div class="warning">
            <strong>âš ï¸ Common Leak Sources:</strong><br />
            1. Static references to Activity<br />
            2. Singletons storing Activity Context<br />
            3. Background threads with Activity reference<br />
            4. Inner classes (implicit reference)<br />
            5. Listeners not unregistered<br />
            6. Handlers with Message/Runnable<br />
            7. AsyncTask (deprecated, but still used)<br />
            8. Large Bitmaps in Activity
          </div>

          <hr />

          <h2>ViewModel ÙˆØ¹Ù„Ø§Ù‚ØªÙ‡ Ø¨Ù€ Lifecycle ğŸ—ï¸</h2>

          <h3>Ù„Ù…Ø§Ø°Ø§ ViewModel Ø­Ù„ Ø³Ø­Ø±ÙŠØŸ</h3>

          <blockquote>
            <strong>ViewModel:</strong> ÙŠØ¹ÙŠØ´ Ø£Ø·ÙˆÙ„ Ù…Ù† Activity!<br />
            <br />
            â€¢ ÙŠÙ†Ø¬Ùˆ Ù…Ù† Configuration Changes (rotation)<br />
            â€¢ ÙŠÙØ¯Ù…Ø± ÙÙ‚Ø· Ø¹Ù†Ø¯ Activity.finish()<br />
            â€¢ Ù„Ø§ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Context (No leaks!)<br />
            â€¢ Ù…ÙƒØ§Ù† Ù…Ø«Ø§Ù„ÙŠ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„Ù€ Logic<br />
            <br />
            <strong>â†’ ViewModel = Ù†Ù‡Ø§ÙŠØ© Ù…Ø´Ø§ÙƒÙ„ Rotation!</strong>
          </blockquote>

          <h3>ViewModel Lifecycle:</h3>

          <div dir="ltr">
            <pre>ViewModel vs Activity Lifecycle:

Activity Lifecycle:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ onCreate() â”€â”€â”€â”€â”                           â”‚
â”‚ onStart()      â”‚                           â”‚
â”‚ onResume()     â”‚  Activity Active          â”‚
â”‚ onPause()      â”‚                           â”‚
â”‚ onStop()       â”‚                           â”‚
â”‚ onDestroy() â”€â”€â”€â”˜                           â”‚
â”‚                                            â”‚
â”‚ [Rotation] ğŸ”„                              â”‚
â”‚                                            â”‚
â”‚ onCreate() â”€â”€â”€â”€â”                           â”‚
â”‚ onStart()      â”‚                           â”‚
â”‚ onResume()     â”‚  Activity Recreated       â”‚
â”‚ ...            â”‚                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ViewModel Lifecycle:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Created â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                            â”‚
â”‚ ViewModel ALIVE                            â”‚ â† Survives rotation!
â”‚ (Unchanged!)                               â”‚
â”‚                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ onCleared() â† Called ONLY when             â”‚
â”‚               Activity.finish()            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Timeline:
Activity 1 â†’ onCreate
          â†’ ViewModel created
Activity 1 â†’ onDestroy (rotation)
          â†’ ViewModel STILL ALIVE! âœ“
Activity 2 â†’ onCreate (recreation)
          â†’ Same ViewModel instance! âœ“
Activity 2 â†’ finish()
          â†’ ViewModel.onCleared()
          â†’ ViewModel destroyed</pre>
          </div>

          <h3>ViewModel Best Practices:</h3>

          <div dir="ltr">
            <pre>// âœ… Correct ViewModel usage
class UserViewModel : ViewModel() {
    // âœ“ LiveData/StateFlow for data
    private val _users = MutableLiveData<List<User>>()
    val users: LiveData<List<User>> = _users
    
    // âœ“ Repository (uses Application Context)
    private val repository = UserRepository(getApplication())
    
    init {
        loadUsers()
    }
    
    fun loadUsers() {
        viewModelScope.launch {
            val data = repository.getUsers()
            _users.value = data
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        // Clean up resources
        repository.cleanup()
    }
}

// In Activity:
class MainActivity : AppCompatActivity() {
    private val viewModel: UserViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Observer setup - safe from rotation!
        viewModel.users.observe(this) { users ->
            updateUI(users)
        }
        
        // After rotation: SAME ViewModel instance âœ“
        // No need to reload data!
    }
}


// âŒ Common mistakes:
class BadViewModel(
    private val context: Context  // âŒ LEAK if Activity Context!
) : ViewModel() {
    private val textView: TextView? = null  // âŒ LEAK!
    
    fun doSomething() {
        context.startActivity(...)  // âŒ Leaked context!
    }
}

// âœ… If you need Context:
class GoodViewModel(
    application: Application  // âœ“ Safe! (use AndroidViewModel)
) : AndroidViewModel(application) {
    
    private val appContext = application.applicationContext
    
    fun doSomething() {
        // Use appContext safely âœ“
    }
}</pre>
          </div>

          <hr />

          <h2>Configuration Changes ğŸ”„</h2>

          <h3>Ù…Ø§ Ù‡Ùˆ Configuration ChangeØŸ</h3>

          <blockquote>
            <strong>Configuration Change:</strong> ØªØºÙŠÙŠØ± ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø² ÙŠØªØ·Ù„Ø¨ Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ UI<br />
            <br />
            <strong>Ø£Ù…Ø«Ù„Ø©:</strong><br />
            â€¢ Screen rotation (Ø£ÙƒØ«Ø±Ù‡Ø§ Ø´ÙŠÙˆØ¹Ø§Ù‹)<br />
            â€¢ Language change<br />
            â€¢ Dark mode toggle<br />
            â€¢ Screen size change (fold/unfold)<br />
            â€¢ Keyboard availability<br />
            <br />
            <strong>Default behavior:</strong> Activity ØªÙØ¯Ù…Ø± ÙˆØªÙØ¹Ø§Ø¯ Ø¨Ù†Ø§Ø¤Ù‡Ø§!
          </blockquote>

          <h3>Ù…Ø§ ÙŠØ­Ø¯Ø« Ø¹Ù†Ø¯ Rotation:</h3>

          <div dir="ltr">
            <pre>Configuration Change Timeline:

T=0ms: User rotates device ğŸ”„
       â””â”€â†’ System detects rotation

T=10ms: Start destroying Activity
        â”œâ”€â†’ onPause()
        â”œâ”€â†’ onStop()
        â”œâ”€â†’ onSaveInstanceState(outState)  âš¡ Save state!
        â”œâ”€â†’ onDestroy()
        â””â”€â†’ Activity object destroyed

T=50ms: ViewModel survives! âœ“
        (Not destroyed, same instance)

T=100ms: Start creating new Activity
         â”œâ”€â†’ onCreate(savedInstanceState)  âš¡ Restore state!
         â”œâ”€â†’ setContentView() with new orientation layout
         â”œâ”€â†’ onStart()
         â””â”€â†’ onResume()

T=200ms: UI ready with new orientation

Result:
â€¢ Old Activity: destroyed (GC'd)
â€¢ New Activity: created (different instance)
â€¢ ViewModel: same instance! âœ“
â€¢ Process: same (no restart)
â€¢ Application: same (no onCreate)</pre>
          </div>

          <h3>ÙƒÙŠÙ ØªØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Configuration ChangesØŸ</h3>

          <h4>Option 1: Handle it (Default - Recommended):</h4>

          <div dir="ltr">
            <pre>// âœ… Best practice: Let Android handle it

1. Save state in onSaveInstanceState:
override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)
    outState.putString("user_input", editText.text.toString())
    outState.putInt("scroll_pos", recyclerView.scrollY)
}

2. Restore in onCreate:
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    
    savedInstanceState?.let {
        editText.setText(it.getString("user_input"))
        recyclerView.scrollY = it.getInt("scroll_pos")
    }
}

3. Use ViewModel for complex data:
class MainViewModel : ViewModel() {
    val users = liveData {
        emit(repository.getUsers())  // Survives rotation âœ“
    }
}

Benefits:
â€¢ Proper resource handling (different layouts for orientations)
â€¢ System-managed
â€¢ No configuration in manifest needed
â€¢ Best for most cases âœ“</pre>
          </div>

          <h4>Option 2: Handle yourself (Not Recommended):</h4>

          <div dir="ltr">
            <pre>// âš ï¸ Prevent recreation (use sparingly!)

// In AndroidManifest.xml:
<activity
    android:name=".MainActivity"
    android:configChanges="orientation|screenSize|keyboardHidden" />

// In Activity:
override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    
    // Handle configuration change manually
    when (newConfig.orientation) {
        Configuration.ORIENTATION_LANDSCAPE -> {
            // Update UI for landscape
        }
        Configuration.ORIENTATION_PORTRAIT -> {
            // Update UI for portrait
        }
    }
}

Drawbacks:
âŒ You must handle ALL orientation logic manually
âŒ Can't use different layouts per orientation
âŒ More complex to maintain
âŒ Easy to mess up

Use only when:
â€¢ Camera preview (shouldn't restart)
â€¢ Video player (shouldn't interrupt)
â€¢ Games (complex state)</pre>
          </div>

          <hr />

          <h2>Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ© Ù…Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ ğŸ’¡</h2>

          <h3>Ù…Ø«Ø§Ù„ 1: Login Screen</h3>

          <div dir="ltr">
            <pre>// Complete lifecycle handling

class LoginActivity : AppCompatActivity() {
    private lateinit var binding: ActivityLoginBinding
    private val viewModel: LoginViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityLoginBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        // Observe login state (survives rotation)
        viewModel.loginState.observe(this) { state ->
            when (state) {
                is LoginState.Loading -> showLoading()
                is LoginState.Success -> navigateToMain()
                is LoginState.Error -> showError(state.message)
            }
        }
        
        // Restore user input after rotation
        savedInstanceState?.let {
            binding.emailEditText.setText(it.getString("email"))
        }
        
        binding.loginButton.setOnClickListener {
            val email = binding.emailEditText.text.toString()
            val password = binding.passwordEditText.text.toString()
            viewModel.login(email, password)
        }
    }
    
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // Save email (not password for security!)
        outState.putString("email", binding.emailEditText.text.toString())
    }
}

class LoginViewModel(
    application: Application  // âœ“ Safe context
) : AndroidViewModel(application) {
    
    private val repository = AuthRepository(application.applicationContext)
    
    private val _loginState = MutableLiveData<LoginState>()
    val loginState: LiveData<LoginState> = _loginState
    
    fun login(email: String, password: String) {
        viewModelScope.launch {
            _loginState.value = LoginState.Loading
            
            try {
                val result = repository.login(email, password)
                _loginState.value = LoginState.Success(result)
            } catch (e: Exception) {
                _loginState.value = LoginState.Error(e.message ?: "Unknown error")
            }
        }
    }
}

Benefits:
â€¢ Email preserved across rotation âœ“
â€¢ Login state survives rotation âœ“
â€¢ No memory leaks âœ“
â€¢ Clean separation of concerns âœ“</pre>
          </div>

          <h3>Ù…Ø«Ø§Ù„ 2: Complex Fragment Communication</h3>

          <div dir="ltr">
            <pre>// Shared ViewModel between Fragments

class SharedViewModel : ViewModel() {
    private val _selectedItem = MutableLiveData<Item>()
    val selectedItem: LiveData<Item> = _selectedItem
    
    fun selectItem(item: Item) {
        _selectedItem.value = item
    }
}

// Fragment 1: List
class ListFragment : Fragment() {
    // Activity-scoped ViewModel (shared!)
    private val sharedViewModel: SharedViewModel by activityViewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        adapter.onItemClick = { item ->
            sharedViewModel.selectItem(item)  // âœ“
        }
        
        // Use viewLifecycleOwner (not 'this')!
        sharedViewModel.selectedItem.observe(viewLifecycleOwner) { item ->
            // Update UI
        }
    }
}

// Fragment 2: Detail
class DetailFragment : Fragment() {
    // Same ViewModel instance! âœ“
    private val sharedViewModel: SharedViewModel by activityViewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // Observe selected item
        sharedViewModel.selectedItem.observe(viewLifecycleOwner) { item ->
            displayItem(item)  // âœ“
        }
    }
}

Benefits:
â€¢ Fragments communicate without tight coupling âœ“
â€¢ Survives configuration changes âœ“
â€¢ Automatic lifecycle management âœ“
â€¢ No memory leaks (viewLifecycleOwner) âœ“</pre>
          </div>

          <h3>Ù…Ø«Ø§Ù„ 3: Service Communication</h3>

          <div dir="ltr">
            <pre>// Service accessing Application safely

class MyService : Service() {
    
    // âœ“ Service IS-A Context (ContextWrapper)
    // But should use Application Context for long-lived objects
    
    private lateinit var repository: DataRepository
    
    override fun onCreate() {
        super.onCreate()
        
        // âœ“ Use Application Context for repository
        repository = DataRepository(applicationContext)
        
        // âœ“ Service context is safe here (Service lifecycle)
        val notificationManager = getSystemService(NOTIFICATION_SERVICE)
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Do work...
        
        // âœ“ Safe: Service lives long enough
        repository.syncData()
        
        return START_STICKY
    }
    
    override fun onDestroy() {
        super.onDestroy()
        repository.cleanup()
    }
}

class DataRepository(
    private val context: Context  // Application Context passed in
) {
    private val database = context.getDatabasePath("mydb")
    
    // âœ“ Safe: Application Context lives entire process
}</pre>
          </div>

          <hr />

          <h2>Ø§Ù„Ø®Ù„Ø§ØµØ© ÙˆØ§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ğŸ“</h2>

          <h3>Ù…Ù„Ø®Øµ Lifecycle:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ù…ÙƒÙˆÙ†</th>
                <th>Lifetime</th>
                <th>Ù…ØªÙ‰ ÙŠÙØ¯Ù…Ø±ØŸ</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Process</strong></td>
                <td>Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹ (hours/days)</td>
                <td>Low memory, Force stop</td>
              </tr>
              <tr>
                <td><strong>Application</strong></td>
                <td>= Process lifetime</td>
                <td>= Process killed</td>
              </tr>
              <tr>
                <td><strong>ViewModel</strong></td>
                <td>Activity finish</td>
                <td>finish(), not rotation</td>
              </tr>
              <tr>
                <td><strong>Activity</strong></td>
                <td>Ù‚ØµÙŠØ± (minutes)</td>
                <td>finish(), rotation, back</td>
              </tr>
              <tr>
                <td><strong>Fragment</strong></td>
                <td>â‰¤ Activity lifetime</td>
                <td>Transaction, Activity destroyed</td>
              </tr>
              <tr>
                <td><strong>View</strong></td>
                <td>â‰¤ Activity/Fragment</td>
                <td>UI recreation</td>
              </tr>
            </tbody>
          </table>

          <h3>Context Decision Matrix:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ø­Ø§Ù„Ø©</th>
                <th>Ø§Ø³ØªØ®Ø¯Ù…</th>
                <th>Ø§Ù„Ø³Ø¨Ø¨</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>UI (View, Dialog, Toast)</td>
                <td>Activity Context</td>
                <td>Needs Theme</td>
              </tr>
              <tr>
                <td>Singleton, Repository</td>
                <td>Application Context</td>
                <td>Avoid leaks</td>
              </tr>
              <tr>
                <td>Database, SharedPrefs</td>
                <td>Application Context</td>
                <td>Long lifetime</td>
              </tr>
              <tr>
                <td>Start Activity</td>
                <td>Activity Context</td>
                <td>Task stack</td>
              </tr>
              <tr>
                <td>System Service</td>
                <td>Either (prefer Activity)</td>
                <td>Same result</td>
              </tr>
              <tr>
                <td>BroadcastReceiver (global)</td>
                <td>Application Context</td>
                <td>App-wide scope</td>
              </tr>
            </tbody>
          </table>

          <h3>Golden Rules:</h3>

          <div dir="ltr">
            <pre>âœ“ Application.onCreate() = Process lifetime (once)
âœ“ Activity.onCreate() = Screen lifetime (many times)
âœ“ onDestroy() NOT guaranteed â†’ save in onStop()
âœ“ onSaveInstanceState() for transient UI state
âœ“ ViewModel for data that survives rotation
âœ“ Application Context for Singletons (no leaks)
âœ“ Activity Context for UI (needs Theme)
âœ“ Fragment: use viewLifecycleOwner (not 'this')
âœ“ Never store Activity Context in static/Singleton
âœ“ Configuration Change = Activity recreation (default)
âœ“ Process = Theater, Application = Management, Activity = Stage</pre>
          </div>

          <h3>Best Practices:</h3>

          <div class="success">
            <strong>âœ… Ø§Ù„Ù†ØµØ§Ø¦Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:</strong><br />
            <br />
            <strong>1. Lifecycle Awareness:</strong><br />
            â€¢ Ø§Ø­ÙØ¸ State ÙÙŠ onSaveInstanceState()<br />
            â€¢ Ø§Ø­ÙØ¸ Data ÙÙŠ onStop() (Ù„ÙŠØ³ onDestroy!)<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… ViewModel Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… lifecycleScope Ù„Ù„Ù€ Coroutines<br />
            <br />
            <strong>2. Context Management:</strong><br />
            â€¢ UI = Activity Context<br />
            â€¢ Singletons = Application Context<br />
            â€¢ Ù„Ø§ ØªØ®Ø²Ù† Activity Context ÙÙŠ Static<br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… context.applicationContext Ù„Ù„Ù€ long-lived objects<br />
            <br />
            <strong>3. Memory Leak Prevention:</strong><br />
            â€¢ Ø§Ø³ØªØ®Ø¯Ù… LeakCanary (debug builds)<br />
            â€¢ Ù„Ø§ Inner classes (implicit reference)<br />
            â€¢ WeakReference Ù„Ù„Ù€ Activity ÙÙŠ threads<br />
            â€¢ Unregister listeners ÙÙŠ onDestroy()<br />
            <br />
            <strong>4. Fragment Best Practices:</strong><br />
            â€¢ viewLifecycleOwner Ù„Ù„Ù€ Observers<br />
            â€¢ onViewCreated() Ù„Ù„Ù€ View access<br />
            â€¢ activityViewModels() Ù„Ù„Ù€ Shared data<br />
            â€¢ Clean up ÙÙŠ onDestroyView()<br />
            <br />
            <strong>5. Configuration Changes:</strong><br />
            â€¢ Ø¯Ø¹ Android ÙŠØ¯ÙŠØ±Ù‡Ø§ (default)<br />
            â€¢ ViewModel + savedInstanceState<br />
            â€¢ Ù„Ø§ ØªÙ…Ù†Ø¹ Recreation Ø¥Ù„Ø§ Ù„Ù„Ø¶Ø±ÙˆØ±Ø©<br />
            â€¢ Ø§Ø®ØªØ¨Ø± Rotation Ø¯Ø§Ø¦Ù…Ø§Ù‹!
          </div>

          <h3>Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø¨ØªØ¯Ø¦ ÙˆØ§Ù„Ù…Ø­ØªØ±Ù:</h3>

          <table>
            <thead>
              <tr>
                <th>Ø§Ù„Ù…Ø¨ØªØ¯Ø¦</th>
                <th>Ø§Ù„Ù…Ø­ØªØ±Ù</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>ÙŠØ­ÙØ¸ ÙÙŠ onDestroy() ÙÙ‚Ø·</td>
                <td>ÙŠØ­ÙØ¸ ÙÙŠ onStop() + onSaveInstanceState</td>
              </tr>
              <tr>
                <td>Ù„Ø§ ÙŠÙÙ‡Ù… Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Application Ùˆ Activity Context</td>
                <td>ÙŠØ®ØªØ§Ø± Context Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„ÙƒÙ„ Ø­Ø§Ù„Ø©</td>
              </tr>
              <tr>
                <td>ÙŠØ®Ø²Ù† Activity ÙÙŠ Static</td>
                <td>ÙŠØ³ØªØ®Ø¯Ù… Application Context Ø£Ùˆ WeakReference</td>
              </tr>
              <tr>
                <td>Ù„Ø§ ÙŠØ®ØªØ¨Ø± Rotation</td>
                <td>ÙŠØ®ØªØ¨Ø± Rotation Ù‚Ø¨Ù„ ÙƒÙ„ Release</td>
              </tr>
              <tr>
                <td>Ù„Ø§ ÙŠØ³ØªØ®Ø¯Ù… ViewModel</td>
                <td>ViewModel Ù„ÙƒÙ„ Screen</td>
              </tr>
              <tr>
                <td>Fragment: ÙŠØ³ØªØ®Ø¯Ù… 'this' Ù„Ù„Ù€ Observe</td>
                <td>Fragment: ÙŠØ³ØªØ®Ø¯Ù… 'viewLifecycleOwner'</td>
              </tr>
            </tbody>
          </table>

          <hr />

          <h2>Ø®Ø§ØªÙ…Ø© ğŸ</h2>

          <blockquote>
            <strong>Lifecycle Ù„ÙŠØ³ Ù…Ø¬Ø±Ø¯ Callbacks</strong><br />
            <br />
            Ù‡Ùˆ <strong>ÙÙ‡Ù… Ø¹Ù…ÙŠÙ‚</strong> Ù„ÙƒÙŠÙÙŠØ© Ø¹Ù…Ù„ Android:<br />
            â€¢ Process = Ø§Ù„Ù…Ø¨Ù†Ù‰ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ (Ø§Ù„Ø£Ø³Ø§Ø³)<br />
            â€¢ Application = Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©<br />
            â€¢ Activity = Ø§Ù„Ù…Ø³Ø±Ø­ Ø§Ù„Ù…ØªØºÙŠØ±<br />
            â€¢ Fragment = Ø§Ù„Ù…Ù…Ø«Ù„ÙˆÙ†<br />
            â€¢ View = Ø§Ù„Ø¯ÙŠÙƒÙˆØ±<br />
            <br />
            <strong>Ø¹Ù†Ø¯Ù…Ø§ ØªÙÙ‡Ù… Lifecycle:</strong><br />
            âœ“ ØªÙÙ‡Ù… Ù…ØªÙ‰ ÙŠÙØ®Ù„Ù‚ ÙˆÙŠÙØ¯Ù…Ø± ÙƒÙ„ Ø´ÙŠØ¡<br />
            âœ“ ØªØ­ÙØ¸ State Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­<br />
            âœ“ ØªØªØ¬Ù†Ø¨ Memory Leaks<br />
            âœ“ ØªØ®ØªØ§Ø± Context Ø§Ù„Ù…Ù†Ø§Ø³Ø¨<br />
            âœ“ ØªØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Rotation Ø¨Ø³Ù„Ø§Ø³Ø©<br />
            âœ“ ØªØ¨Ù†ÙŠ ØªØ·Ø¨ÙŠÙ‚Ø§Øª ØªÙ†Ø¬Ùˆ Ù…Ù† Process Death<br />
            <br />
            <strong>Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³ Ø§Ù„Ù…Ø­ØªØ±Ù ÙŠÙÙ‡Ù…: Lifecycle Ù‡Ùˆ Ø§Ù„Ù‚Ù„Ø¨ Ø§Ù„Ù†Ø§Ø¨Ø¶ Ù„Ù€ Android. ğŸ’“</strong>
          </blockquote>

          <div class="info">
            <strong>ğŸ’¡ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©:</strong><br />
            1. Ø§ÙØªØ­ ØªØ·Ø¨ÙŠÙ‚Ùƒ<br />
            2. Developer Options â†’ "Don't keep activities"<br />
            3. Ø§Ø®ØªØ¨Ø± ÙƒÙ„ Screen<br />
            4. ØªØ£ÙƒØ¯ State ÙŠÙØ­ÙØ¸ ÙˆÙŠÙØ³ØªØ±Ø¬Ø¹<br />
            5. Ø§Ø®ØªØ¨Ø± Rotation (Ctrl+F11/F12 ÙÙŠ Emulator)<br />
            6. Ø§Ø³ØªØ®Ø¯Ù… LeakCanary<br />
            7. Profile Memory Ø¨Ø¹Ø¯ 10 Rotations<br />
            8. Search "Activity" ÙÙŠ Heap dump â†’ Should be 1!<br />
            <br />
            <strong>â†’ Lifecycle mastery = Android mastery! ğŸ¯</strong>
          </div>

        </div>
      </div>
    </div>
  </div>
</body>
</html>
